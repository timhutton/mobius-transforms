<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="code/drawing.js"></script>
<script src="code/math.js"></script>
<script>

function toScreen( p ) {
    return add( origin_screen, complex_conjugate( mul( p, scale ) ) );
}

function fromScreen( p ) {
    return mul( complex_conjugate( sub( p, origin_screen ) ), 1.0 / scale );
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onTouchMove( evt ) {
    if( point_is_being_dragged )
        evt.preventDefault();
    onMove( fixTouch( evt.changedTouches[0] ) );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        var p = fromScreen( add( pos, drag_offset ) );
        var v = sub( p, control_points[ i_point ] );
        control_points[ i_point ] = p;
        if( i_point % 2 == 0 ) {
            // dragging the center also drags the edge marker
            control_points[ i_point + 1 ] = add( control_points[ i_point + 1 ], v );
        }
        draw();
    }
    else {
        // find the closest point, if within a minimum radius
        var iClosest = -1;
        var closest_dist2 = touch_radius * touch_radius;
        for( var i = 0; i < control_points.length; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                closest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            draw();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            draw();
        }
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    onDown( fixTouch( evt.changedTouches[0] ) );
}

function onDown( pos ) {
    // find the closest point, if within a minimum radius
    var iClosest = -1;
    var closest_dist2 = touch_radius * touch_radius;
    for( var i = 0; i < control_points.length; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            closest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        drag_offset = sub( toScreen( control_points[ i_point ] ), pos );
        draw();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        draw();
    }
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        draw();
    }
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        draw();
    }
    is_mouse_down = false;
}

// thanks to: http://stackoverflow.com/a/12714084/126823
function fixTouch (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
        // iOS4 clientX/clientY have the value that should have been
        // in pageX/pageY. While pageX/page/ have the value 0
        x = x - winPageX;
        y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX) ) {
        // Some Android browsers have totally bogus values for clientX/Y
        // when scrolling/zooming a page. Detectable since clientX/clientY
        // should never be smaller than pageX/pageY minus page scroll
        x = touch.pageX - winPageX;
        y = touch.pageY - winPageY;
    }
    var rect = canvas.getBoundingClientRect();
    return p2( x - rect.left, y - rect.top );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    canvas.addEventListener( 'touchend',  onMouseUp, false );
    canvas.addEventListener( 'touchcancel',  onMouseUp, false );

    control_points = [ p2( -1.0, 0.0 ), p2( 0.0, 0.0 ),
                       p2( 1.0, 0.0 ), p2( 2.0, 0.0 ),
                       p2( 0.9, 1.0 ), p2( 0.5, 1.0 ) ];

    origin_screen = p2( canvas.width/2, canvas.height/2 );
    scale = Math.min( canvas.width, canvas.height ) / 6;

    point_is_highlighted = false;
    point_is_being_dragged = false;
    i_point = -1;
    grab_offset = p2( 0, 0 );

    touch_radius = 50;

    draw();
}

function drawPoint( p, r, t, t_offset ) {
    ctx.beginPath();
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI );
    ctx.fillText( t, p.x + 5 + t_offset.x, p.y - 5 + t_offset.y );
    ctx.fill();
}

// adapted from http://stackoverflow.com/a/6333775/126823
function drawArrow( from, to ) {
    var headlen = 5; // length of head in pixels
    var angle = Math.atan2(to.y-from.y,to.x-from.x);
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.moveTo(to.x-headlen*Math.cos(angle-Math.PI/6),to.y-headlen*Math.sin(angle-Math.PI/6));
    ctx.lineTo(to.x, to.y);
    ctx.lineTo(to.x-headlen*Math.cos(angle+Math.PI/6),to.y-headlen*Math.sin(angle+Math.PI/6));
}

function drawSmoothTransformedLine( a, c, mobius_transform, recursion_depth = 1 ) {
    var b = average( a, c );
    var qa = a,qb = b,qc = c;
    if( mobius_transform ) {
        qa = mobius_on_point( mobius_transform, qa );
        qb = mobius_on_point( mobius_transform, qb );
        qc = mobius_on_point( mobius_transform, qc );
    }
    var sa = toScreen( qa );
    var sb = toScreen( qb );
    var sc = toScreen( qc );
    // if nearly collinear then just draw straight lines
    var close_enough = 3;
    if( recursion_depth > 5 || distanceOfPointFromLine( sa, sc, sb ) < close_enough ) {
        ctx.moveTo( sa.x, sa.y );
        ctx.lineTo( sb.x, sb.y );
        ctx.lineTo( sc.x, sc.y );
        return;
    }
    // otherwise recurse down
    drawSmoothTransformedLine( a, b, mobius_transform, on_sphere, recursion_depth + 1 );
    drawSmoothTransformedLine( b, c, mobius_transform, on_sphere, recursion_depth + 1 );
}

function drawSmoothTransformedArrow( p ) {
    // interpolate between the identity transform and the current transform
    var sp2 = toScreen( p );
    ctx.moveTo( sp2.x, sp2.y );
    var num_steps = 30;
    var cp = [];
    var target_p = control_points.slice();
    mobius_normalize( target_p );
    for( var i = 0; i < num_steps; i++ ) {
        var u = i / num_steps;
        mobius_identity( cp );
        for( var j = 0; j < 4; j++ )
            cp[ j ] = add( mul( target_p[ j ], u ), mul( cp[ j ], 1 - u ) );
        var q = mobius( p, cp[0], cp[1], cp[2], cp[3] );
        sq = toScreen( q );
        ctx.lineTo( sq.x, sq.y );
    }
    // draw the arrow using the last line segment
    var q = mobius_on_point( control_points, p );
    var sq2 = toScreen( q );
    drawArrow( sq, sq2 );
}

function draw() {

    // clear the area
    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.lineWidth = 1;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // draw the axes
    var extent = 6;
    ctx.strokeStyle = "rgba(0,0,0,0.2)";
    ctx.beginPath();
    drawSmoothTransformedLine( p2( -extent, 0 ), p2( 0, 0 ), null, false );
    drawSmoothTransformedLine( p2( 0, 0 ), p2( extent, 0 ), null, false );
    drawSmoothTransformedLine( p2( 0, -extent ), p2( 0, 0 ), null, false );
    drawSmoothTransformedLine( p2( 0, 0 ), p2( 0, extent ), null, false );
    for( var i = -extent; i <= extent; i++ ) {
        drawSmoothTransformedLine( p2( i, -0.05 ), p2( i, 0.05 ), null, false );
        drawSmoothTransformedLine( p2( -0.05, i ), p2( 0.05, i ), null, false );
    }
    ctx.stroke();

    // draw the four control points
    ctx.font="22px Arial";
    var rest_color = "rgb(0,0,0)";
    var highlighted_color = "rgb(0,255,255)";
    var dragging_color = "rgb(0,255,0)";
    for( var i = 0; i < control_points.length; i++ ) {
        if( point_is_highlighted && i_point == i )
            ctx.fillStyle = ctx.strokeStyle = highlighted_color;
        else if( point_is_being_dragged && i_point == i )
            ctx.fillStyle = ctx.strokeStyle = dragging_color;
        else
            ctx.fillStyle = ctx.strokeStyle = rest_color;
        var radius = 4;
        drawPoint( toScreen( control_points[ i ] ), radius, (i%2)==0?String.fromCharCode(65 + i/2):"", p2(0,0) );
    }

    // draw the circles
    ctx.strokeStyle = "rgba(255,0,0,0.8)";
    for(var iCircle = 0; iCircle < control_points.length/2; iCircle++) {
        var c = toScreen(control_points[2 * iCircle]);
        var r = dist(c, toScreen(control_points[2 * iCircle + 1]));
        drawCircle(c, r);
    }

    // find the mobius transforms defined by the circles
    var D_A = {p:control_points[0], r:dist(control_points[0], control_points[1])};
    var D_a = {p:control_points[2], r:dist(control_points[2], control_points[3])};
    var c = {p:control_points[4], r:dist(control_points[4], control_points[5])};
    var m_a = pair_circles( D_A, D_a );
    var m_A = pair_circles( D_a, D_A );

    // transform the circles repeatedly
    var x = c;
    for(var i = 0; i < 4; i++) {
        ctx.strokeStyle = "rgba(0, 0, 155, " + Math.pow(0.6, i) + ")";
        x = mobius_on_circle( m_a, x );
        drawWorldSpaceCircle(x);
    }
}

function drawWorldSpaceCircle( c ) {
    var sc = toScreen(c.p);
    var sr = dist(sc, toScreen(add(c.p, p2(c.r,0))));
    drawCircle(sc, sr);
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input[type='button'] {
    font-size: 20px;
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
}
</style>

</head>

<body>

<div style="float:left;touch-action:none"><p><canvas id="canvas" width="700" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

</div>
</html>
