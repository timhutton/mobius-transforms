<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="code/math.js"></script>
<script src="code/recipes.js"></script>
<script>

function toScreen( p ) {
    return add( origin_screen, complex_conjugate( mul( sub( p, offset ), scale ) ) );
}

function fromScreen( p ) {
    return add( mul( complex_conjugate( sub( p, origin_screen ) ), 1.0 / scale ), offset);
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onTouchMove( evt ) {
    if( point_is_being_dragged )
        evt.preventDefault();
    onMove( fixTouch( evt.changedTouches[0] ) );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        control_points[ i_point ] = fromScreen( add( pos, drag_offset ) );
        need_redraw_image = true;
        need_recompute = true;
        checkForPendingCommands();
    }
    else if( is_panning ) {
        var move = sub( fromScreen( drag_offset ), fromScreen( pos ) );
        offset = add( offset, move );
        need_redraw = true;
        need_redraw_image = true;
        checkForPendingCommands();
        drag_offset = pos;
    }
    else {
        // find the closest point, if within a minimum radius
        var iClosest = -1;
        var closest_dist2 = touch_radius * touch_radius;
        var num_control_points = control_points.length;
        for( var i = 0; i < num_control_points; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                closest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            need_redraw = true;
            checkForPendingCommands();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            need_redraw = true;
            checkForPendingCommands();
        }
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    onDown( fixTouch( evt.changedTouches[0] ) );
}

function onDown( pos ) {
    // find the closest point, if within a minimum radius
    var iClosest = -1;
    var closest_dist2 = touch_radius * touch_radius;
    var num_control_points = control_points.length;
    for( var i = 0; i < num_control_points; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            closest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        drag_offset = sub( toScreen( control_points[ i_point ] ), pos );
        need_redraw = true;
        checkForPendingCommands();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        need_redraw = true;
        checkForPendingCommands();
    }
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        need_redraw = true;
        checkForPendingCommands();
    }
    else {
        is_panning = true;
        drag_offset = pos;
    }
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        need_redraw = true;
        checkForPendingCommands();
    }
    is_mouse_down = false;
    is_panning = false;
}

// thanks to: http://stackoverflow.com/a/12714084/126823
function fixTouch (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
        // iOS4 clientX/clientY have the value that should have been
        // in pageX/pageY. While pageX/page/ have the value 0
        x = x - winPageX;
        y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX) ) {
        // Some Android browsers have totally bogus values for clientX/Y
        // when scrolling/zooming a page. Detectable since clientX/clientY
        // should never be smaller than pageX/pageY minus page scroll
        x = touch.pageX - winPageX;
        y = touch.pageY - winPageY;
    }
    var rect = canvas.getBoundingClientRect();
    return p2( x - rect.left, y - rect.top );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    canvas.addEventListener( 'touchend',  onMouseUp, false );
    canvas.addEventListener( 'touchcancel',  onMouseUp, false );

    origin_screen = p2( canvas.width/2, canvas.height/2 );
    reset_viewport();

    point_is_highlighted = false;
    point_is_being_dragged = false;
    is_panning = false;
    i_point = -1;
    grab_offset = p2( 0, 0 );
    need_recompute = true;
    need_redraw_image = false;
    need_redraw = false;
    redrawing_image = false;
    recomputing = false;

    touch_radius = 50;

    draw_control_points = true;
    draw_fixed_points = false;

    // initialise the recipes
    recipes = get_recipes();
    var recipes_dropdown = document.getElementById('recipes_dropdown');
    for( var i = 0; i < recipes.length; i++ ) {
        var el = document.createElement("option");
        el.textContent = recipes[i].label;
        el.value = recipes[i].label;
        recipes_dropdown.appendChild(el);
    }
    iRecipe = 8;
    recipes_dropdown.selectedIndex = iRecipe;

    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    image = ctx.getImageData(0, 0, canvas.width, canvas.height);
    pixels = image.data;

    plot_solution = [ true, true ];
    document.getElementById("which_solution_dropdown").selectedIndex = 2;

    plot_ifs = false;
    plot_dfs = true;
    document.getElementById("which_method_dropdown").selectedIndex = 1;

    hq_mode = false;
    set_quality_parameters( hq_mode );

    worker = new Worker( 'code/worker.js' );
    worker.addEventListener( 'message', handleWorkerResponse );

    checkForPendingCommands();
}

function checkForPendingCommands() {
    if( need_redraw ) {
        draw();
    }
    if( need_redraw_image && !redrawing_image ) {
        draw_image();
    }
    if( need_recompute && !recomputing ) {
        compute();
    }
}

function reset_viewport() {
    scale = Math.min( canvas.width, canvas.height ) / 4.5;
    offset = p2( 0.0, 0.0 );
}

function drawPoint( p, r, t, t_offset ) {
    ctx.beginPath();
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI );
    ctx.fillText( t, p.x + t_offset.x - 5, p.y - t_offset.y );
    ctx.fill();
}

function draw_image() {

    redrawing_image = true;
    need_redraw_image = false;

    const time_start = performance.now();

    clear_image();

    if(false) { // old code to draw from output_pts
        // draw the loop into the image buffer
        for( var which_solution = 0; which_solution < output_pts.length; which_solution++) {
            var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
            // draw the separate line segments
            for(var i = 0; i < output_pts[which_solution].length; i++) {
                if( output_pts[which_solution][i].length == 0 ) { continue; }
                var a = output_pts[which_solution][i][0].p, b;
                for(var j = 0; j < output_pts[which_solution][i].length; j++) {
                    b = output_pts[which_solution][i][j].p;
                    draw_image_line_with_duplication( a, b, which_solution, duplication_func );
                    a = b;
                }
            }
        }
    } else {
        if(vertices.length > 0 ) {
            var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
            var a = p2( vertices[0], vertices[1] );
            for(var i = 2; i < vertices.length; i += 2) {
                var b = p2( vertices[i], vertices[i+1] );
                draw_image_line_with_duplication( a, b, 0, duplication_func);
                a = b;
            }
        }
    }

    // draw the cloud points into the image buffer
    for( var which_solution = 0; which_solution < cloud_pts.length; which_solution++) {
        for( var i = 0; i < cloud_pts[which_solution].length; i++) {
            var sp = toScreen( cloud_pts[which_solution][i] );
            if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height ) {
                var pixel_offset = ( Math.floor(sp.y) * image.width + Math.floor(sp.x) ) * 4;
                pixels[pixel_offset + which_solution] = 255;
            }
        }
    }

    const time_end = performance.now();
    last_redraw_image_time_ms = time_end - time_start;

    need_redraw = true;
    redrawing_image = false;
    checkForPendingCommands();
}

function draw() {

    need_redraw = false;

    // blit the image to the screen
    ctx.putImageData(image, 0, 0);

    // draw the axes
    if( draw_control_points ) {
        var min = fromScreen( p2( 0.0, canvas.height ) );
        var max = fromScreen( p2( canvas.width, 0.0 ) );
        min = p2( Math.floor( min.x ), Math.floor( min.y ) );
        max = p2( Math.ceil( max.x ), Math.ceil( max.y ) );
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.beginPath();
        drawLine( p2( min.x, 0 ), p2( max.x, 0 ) );
        drawLine( p2( 0, min.y ), p2( 0, max.y ) );
        // unit marks
        for( var x = min.x; x <= max.x; x++ ) {
            drawLine( p2( x, -0.05 ), p2( x, 0.05 ) );
        }
        for( var y = min.y; y <= max.y; y++ ) {
            drawLine( p2( -0.05, y ), p2( 0.05, y ) );
        }
        ctx.stroke();
    }

    // draw the control points
    if( draw_control_points ) {
        ctx.font="22px Arial";
        var rest_color = "rgb(255,255,255)";
        var highlighted_color = "rgb(0,255,255)";
        var dragging_color = "rgb(0,255,0)";
        for( var i = 0; i < control_points.length; i++ ) {
            if( point_is_highlighted && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = highlighted_color;
            else if( point_is_being_dragged && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = dragging_color;
            else
                ctx.fillStyle = ctx.strokeStyle = rest_color;
            var radius = 4;
            var offset = p2( 20.0 * Math.cos(i * Math.PI), 20.0 * Math.sin(i * Math.PI) );
            drawPoint( toScreen( control_points[ i ] ), radius, recipes[ iRecipe ].pt_labels[i], offset );
        }
    }

    if( draw_fixed_points ) {
        ctx.font="12px Arial";
        ctx.fillStyle = "rgb(255,255,255)";
        for( var which_solution = 0; which_solution < debug_pts.length; which_solution++) {
            for( var i = 0; i < debug_pts[which_solution].length; i++ ) {
                drawPoint( toScreen( debug_pts[which_solution][i].p ), 2, debug_pts[which_solution][i].label, p2(Math.random()*40-20, Math.random()*40-20) );
            }
        }
    }

    // draw the debug labels
    if( false ) {
        ctx.font="12px Arial";
        ctx.fillStyle = "rgb(255,255,255)";
        for( var which_solution = 0; which_solution < output_pts.length; which_solution++) {
            for( var i = 0; i < output_pts[which_solution].length; i++ ) {
                for( var j = 0; j < output_pts[which_solution][i].length; j++ ) {
                    drawPoint( toScreen( output_pts[which_solution][i][j].p ), 2, i+':'+j+':'+output_pts[which_solution][i][j].label, p2( 0, i%2==1?10:-10 ) );
                }
            }
        }
    }

    document.getElementById('rendering_text').textContent = "Compute, render: " + formatMilliseconds( last_compute_time_ms ) + ", "
        + formatMilliseconds( last_redraw_image_time_ms );
}

function drawLine( a, b ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    ctx.moveTo( sa.x, sa.y );
    ctx.lineTo( sb.x, sb.y );
}

function onDrawControlPointsButton(element) {
    draw_control_points = !draw_control_points;
    element.value = draw_control_points ? "Draw control points: ON" : "Draw control points: OFF";
    need_redraw = true;
    checkForPendingCommands();
}

function onRecipeChanged(element) {
    iRecipe = recipes_dropdown.selectedIndex;
    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }
    hq_mode = false;
    updateHighQualityModeButton();
    set_quality_parameters( hq_mode );
    reset_viewport();
    need_recompute = true;
    checkForPendingCommands();
}

function set_quality_parameters(hq_mode) {
    if( hq_mode ) {
        num_ifs_iterations = 10000000;
        max_depth = 100;
        closeness_epsilon = 0.003; // if sequential points are closer than this we can stop searching
    }
    else {
        num_ifs_iterations = 100000;
        max_depth = 25;
        closeness_epsilon = 0.01; // if sequential points are closer than this we can stop searching
    }
    document.getElementById('epsilon_input').value = closeness_epsilon;
    document.getElementById('maximum_depth_input').value = max_depth;
    closeness_epsilon2 = closeness_epsilon * closeness_epsilon;
}

function onMaxDepthChanged(element) {
    max_depth = element.value;
    need_recompute = true;
    checkForPendingCommands();
}

function onEpsilonChanged(element) {
    closeness_epsilon = element.value;
    const min_closeness_epsilon = 0.00001;
    if( closeness_epsilon < min_closeness_epsilon ) {
        closeness_epsilon = min_closeness_epsilon;
        element.value = closeness_epsilon;
    }
    closeness_epsilon2 = closeness_epsilon * closeness_epsilon;
    need_recompute = true;
    checkForPendingCommands();
}

function onHighQualityModeButton(element) {
    hq_mode = !hq_mode;
    updateHighQualityModeButton();
    set_quality_parameters( hq_mode );
    need_recompute = true;
    checkForPendingCommands();
}

function updateHighQualityModeButton() {
    document.getElementById('hq_mode_button').value = hq_mode ? "High quality mode: ON" : "High quality mode: OFF";
}

function onZoomInButton(element) {
    scale *= 2.0;
    need_redraw_image = true;
    checkForPendingCommands();
}

function onZoomOutButton(element) {
    scale /= 2.0;
    need_redraw_image = true;
    checkForPendingCommands();
}

function onWhichSolutionChanged(element) {
    plot_solution[0] = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_solution[1] = element.selectedIndex == 1 || element.selectedIndex == 2;
    need_recompute = true;
    checkForPendingCommands();
}

function onWhichMethodChanged(element) {
    plot_ifs = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_dfs = element.selectedIndex == 1 || element.selectedIndex == 2;
    need_recompute = true;
    checkForPendingCommands();
}

function download(filename, type, text) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:'+type+';charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

function getBoundsWithDuplication( pts, duplication_func ) {
    var bounds = { minX: Number.MAX_VALUE, minY: Number.MAX_VALUE, maxX: -Number.MAX_VALUE, maxY: -Number.MAX_VALUE };
    for( var i = 0; i < pts.length; i++) {
        if( isNaN( pts[i].x ) || isNaN( pts[i].y ) ) { continue; }
        var pts_dup = duplication_func( pts[i] );
        for( var j = 0; j < pts_dup.length; j++ ) {
            if( pts_dup[j].x < bounds.minX ) { bounds.minX = pts_dup[j].x; }
            if( pts_dup[j].y < bounds.minY ) { bounds.minY = pts_dup[j].y; }
            if( pts_dup[j].x > bounds.maxX ) { bounds.maxX = pts_dup[j].x; }
            if( pts_dup[j].y > bounds.maxY ) { bounds.maxY = pts_dup[j].y; }
        }
    }
    bounds.width = bounds.maxX - bounds.minX;
    bounds.height = bounds.maxY - bounds.minY;
    return bounds;
}

function getOutputPtsBoundsWithDuplication( scale, duplication_func ) {
    var all_pts = [];
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        for(var i = 0; i < output_pts[which_solution].length; i++) {
            for(var j = 0; j < output_pts[which_solution][i].length; j++) {
                all_pts.push( mul( output_pts[which_solution][i][j].p, scale) );
            }
        }
    }
    var bounds = getBoundsWithDuplication( all_pts, duplication_func );
    return bounds;
}

function onSaveAsSVGButton(element) {
    var scale = 300;
    var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
    var bounds = getOutputPtsBoundsWithDuplication( scale, duplication_func );
    var svg = "<!-- SVG produced by https://github.com/timhutton/mobius-transforms -->\n";
    svg += "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' width='"+bounds.width.toFixed(1)+"px' height='"+bounds.height.toFixed(1)+"px' viewBox='"
        + bounds.minX.toFixed(1) + " " + bounds.minY.toFixed(1) + " " + bounds.width.toFixed(1) + " " + bounds.height.toFixed(1) + "'>\n";
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        for(var i = 0; i < output_pts[which_solution].length; i++) {
            var pts_dup = [];
            for( var k = 0; k < output_pts[which_solution][i].length; k++ ) {
                pts_dup.push( duplication_func( output_pts[which_solution][i][k].p ) );
            }
            for( var k = 0; k < pts_dup[0].length; k++ ) {
                svg += "  <polyline points='";
                for( var iPt = 0; iPt < pts_dup.length; iPt++) {
                    var sp = mul( pts_dup[iPt][k], scale );
                    svg += sp.x.toFixed(3) + ", " + sp.y.toFixed(3) + " "
                }
                svg += "'\n    fill='none' stroke='black' stroke-width='0.3'/>\n";
            }
        }
    }
    svg += "</svg>\n";
    download("dfs.svg", "image/svg+xml", svg);
}

function onSaveAsPNGButton(element) {
    var max_image_dimension = 3000;
    var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
    var bounds = getOutputPtsBoundsWithDuplication( 1.0, duplication_func );
    var scale = max_image_dimension / Math.max( bounds.width, bounds.height );
    var width = bounds.width * scale;
    var height = bounds.height * scale;
    var border = 5;
    // create a large canvas
    var new_canvas = document.createElement('canvas');
    new_canvas.width = width + border * 2;
    new_canvas.height = height + border * 2;
    var context = new_canvas.getContext('2d');
    context.fillStyle = 'rgb(255,255,255)';
    context.fillRect(0, 0, new_canvas.width, new_canvas.height);
    // draw the whole loop
    context.strokeStyle = 'rgba(0,0,0,1.0)';
    context.fillStyle = 'rgba(247, 246, 216, 1.0)';
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        for( var j = 0; j < output_pts[which_solution].length; j++) {
            if(output_pts[which_solution][j].length == 0) { continue; }
            var pts_dup = [];
            for( var k = 0; k < output_pts[which_solution][j].length; k++ ) {
                pts_dup.push( duplication_func( output_pts[which_solution][j][k].p ) );
            }
            for( var k = 0; k < pts_dup[0].length; k++ ) {
                context.beginPath();
                var sp0 = add( mul( sub( pts_dup[0][k], p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border ) );
                context.moveTo( sp0.x, new_canvas.height - sp0.y );
                for(var i = 1; i < pts_dup.length; i++) {
                    var sp = add( mul( sub( pts_dup[i][k], p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border) );
                    context.lineTo( sp.x, new_canvas.height - sp.y );
                }
                context.stroke();
            }
        }
    }
    // save the png
    var downloadLink = document.createElement('a');
    downloadLink.download = 'dfs.png';
    downloadLink.href = new_canvas.toDataURL('image/png');
    downloadLink.click();
}

function compute() {
    recomputing = true;
    need_recompute = false;
    document.getElementById('rendering_text').textContent = "Rendering...";
    start_compute_time = performance.now();
    var solutions_to_plot = [];
    if( plot_solution[0] ) { solutions_to_plot.push( 0 ); }
    if( plot_solution[1] ) { solutions_to_plot.push( 1 ); }
    var params = {
        control_points: control_points,
        solutions_to_plot: solutions_to_plot,
        closeness_epsilon: closeness_epsilon,
        max_depth: max_depth,
        iRecipe: iRecipe
    };
    worker.postMessage( params );
}

function handleWorkerResponse( e ) {

    var result = e.data;
    output_pts = result.output_pts;
    cloud_pts = result.cloud_pts;
    vertices = new Float32Array( result.vertices_buffer );

    last_compute_time_ms = performance.now() - start_compute_time;

    if( result.n_pts_plotted > 0 ) {
        document.getElementById('num_points_text').textContent = "Number of points: " + result.n_pts_plotted;
    }
    else {
        document.getElementById('num_points_text').textContent = "Aborted compute";
    }
    document.getElementById('download_svg_button').disabled = !result.dfs_succeeded;
    document.getElementById('download_png_button').disabled = !result.dfs_succeeded;
    document.getElementById('description_text').innerHTML = "Description: " + result.description;

    need_redraw_image = true;
    recomputing = false;
    checkForPendingCommands();
}

function clear_image() {
    for( var i = 0; i < image.width * image.height; i++) {
        image.data[ i*4 + 0 ] = 0;
        image.data[ i*4 + 1 ] = 0;
        image.data[ i*4 + 2 ] = 0;
        image.data[ i*4 + 3 ] = 255;
    }
}

function duplicate_point( a, recipe ) {
    // return a list of the duplicated points according to the duplication method specified in the recipe
    var pts = [];
    if( !('duplicate' in recipe) ) {
        pts.push( a );
    }
    else if( recipe.duplicate == 'rot180' ) {
        pts.push( a );
        pts.push( mul(a, -1.0) );
    }
    else if( recipe.duplicate == 'rot180_and_rep_x_2' ) { // e.g. riley
        for( var x_offset = -4; x_offset <= 4; x_offset += 2 ) {
            pts.push( add( a, p2( x_offset, 0.0 ) ) );
            pts.push( add( mul(a, -1.0), p2( x_offset, 0.0 ) ) );
        }
    }
    else if( recipe.duplicate == 'maskit' ) {
        var mu = control_points[0];
        for( var x_offset = -4; x_offset <= 4; x_offset += 2 ) {
            pts.push( add( a, p2( x_offset, 0.0 ) ) );
            pts.push( add( mul( sub( a, mu ), -1.0), p2( x_offset, 0.0 ) ) );
        }
    }
    else {
        //console.log('Unknown duplication command:', recipe.duplicate);
        pts.push( a );
    }
    return pts;
}

function draw_image_line_with_duplication( a, b, rgb, duplication_func ) {
    var a_pts = duplication_func( a );
    var b_pts = duplication_func( b );
    for( var i = 0; i < a_pts.length; i++) {
        draw_image_line( a_pts[i], b_pts[i], rgb );
    }
}

function draw_image_line( a, b, rgb ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    // crop to the image rectangle if one or both points are outside
    if( sa.x < 0 || sa.y < 0 || sa.x >= image.width || sa.y >= image.height ||
        sb.x < 0 || sb.y < 0 || sb.x >= image.width || sb.y >= image.height ) {
        var image_corners = [ p2( 0, 0 ), p2( image.width - 1, 0 ), p2( image.width - 1, image.height - 1 ), p2( 0, image.height - 1 ) ];
        var intersections = [];
        for( var i = 0; i < image_corners.length; i++ ) {
            var [intersected, intersection] = find_line_segments_intersection( sa, sb, image_corners[i], image_corners[ (i + 1) % image_corners.length ] );
            if(intersected) { intersections.push( intersection ); }
        }
        if( intersections.length == 0 ) {
            return; // line segment doesn't cross the image
        }
        if( intersections.length == 2 ) {
            sa = intersections[0];
            sb = intersections[1];
        }
        else if( intersections.length == 1 ) {
            if( sa.x < 0 || sa.y < 0 || sa.x >= image.width || sa.y >= image.height )
                sa = intersections[0];
            else
                sb = intersections[0];
        }
        else {
            console.log('Strange number of intersections:', intersections.length, sa, sb);
            return;
        }
    }
    line( sa, sb, (x, y) => {
        if( x < 0 || y < 0 || x >= image.width || y >= image.height ) {
            console.log('Error in draw_image_line: pixel not on image', sa, sb, x, y);
            return;
        }
        pixels[( y * image.width + x ) * 4 + rgb] = 255;
    } );
}

function line(a, b, func) {
    var [x0, y0] = [ Math.trunc(a.x), Math.trunc(a.y) ];
    var [x1, y1] = [ Math.trunc(b.x), Math.trunc(b.y) ];
    if( isNaN(x0) || isNaN(y0) || isNaN(x1) || isNaN(y1) ) { return; }
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    var sx = (x0 < x1) ? 1 : -1;
    var sy = (y0 < y1) ? 1 : -1;
    var err = dx - dy;
    while(true) {
        func(x0, y0);
        if ((x0 === x1) && (y0 === y1)) break;
        var e2 = 2*err;
        if (e2 > -dy) { err -= dy; x0  += sx; }
        if (e2 < dx) { err += dx; y0  += sy; }
    }
}

function last(arr) { return arr[arr.length - 1]; }

/*
function find_nearby_short_word_fixed_points( sp, transforms, which_solution, debug_pts) {
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:B, name:'B'}, {t:A, name:'A'}, {t:b, name:'b'} ];
    var fixed_points_max_depth = 6;
    var shortest_len = 10000;
    var p;
    var found_one = false;
    function explore_tree( x, old_word, prev, level ) {
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var new_word = old_word + gens[ iTag ].name;
            var fp = { p: get_mobius_fixed_points( y )[0], label: new_word };
            var sfp = toScreen( fp.p );
            if( dist2( sp, sfp ) < 400.0 && fp.label.length < shortest_len) {
                shortest_len = fp.label.length;
                p = fp;
                found_one = true;
            }
            if( level < fixed_points_max_depth ) {
                explore_tree( y, new_word, iTag, level + 1 );
            }
        }
    };
    for( var k = 0; k < 4; k++) {
        explore_tree( gens[k].t, gens[k].name, k, 0 );
    }
    if( found_one )
        debug_pts[which_solution] = [ p ];
}*/

/*function find_fixed_points(transforms, which_solution, debug_pts) {
    // for debugging which special words are appropriate for a particular pattern
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:B, name:'B'}, {t:A, name:'A'}, {t:b, name:'b'} ];
    var fixed_points_max_depth = 2;
    function explore_tree( x, old_word, prev, level ) {
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var new_word = old_word + gens[ iTag ].name;
            var fp = { p: get_mobius_fixed_points( y )[0], label: new_word };
            debug_pts[which_solution].push( fp );
            if( level < fixed_points_max_depth ) {
                explore_tree( y, new_word, iTag, level + 1 );
            }
        }
    };
    for( var k = 0; k < 4; k++) {
        var fp = { p: get_mobius_fixed_points( gens[k].t )[0], label: gens[k].name };
        debug_pts[which_solution].push( fp );
        explore_tree( gens[k].t, gens[k].name, k, 0 );
    }
}*/

function draw_ifs(transforms, which_solution) {
    var discard = 20;
    var p = p2(0.0,0.0);
    for( var i = 0; i < num_ifs_iterations + discard; i++) {
        p = mobius_on_point( transforms[Math.floor(Math.random() * transforms.length)], p );
        if( i > discard )
            cloud_pts[which_solution].push( p );
    }
    return num_ifs_iterations;
}

/*
function compute() {

    var n_pts_plotted = 0;
    output_pts = [[],[]];
    debug_pts = [[],[]];
    cloud_pts = [[],[]];
    transforms = [];
    var description = "";
    var dfs_succeeded = true;

    if( plot_dfs ) {
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators( which_solution );
            var [gens, repetends] = get_repetends( transforms );
            n_pts_plotted += dfs_recursive_tree( gens, repetends, which_solution, output_pts );

            if( draw_fixed_points ) {
                find_fixed_points(transforms, which_solution, debug_pts);
            }
        }
    }

    if(n_pts_plotted == 0) {
        // DFS rendering failed, clear the drawing and draw IFS instead
        dfs_succeeded = false;
        output_pts = [[],[]];
        clear_drawing();
    }

    if(!dfs_succeeded || plot_ifs) {
        // run IFS
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators( which_solution );
            n_pts_plotted += draw_ifs( transforms, which_solution );
        }
    }

    return [dfs_succeeded, n_pts_plotted, description];
}*/

function formatMilliseconds( ms ) {
    if( ms > 1000.0 ) {
        return (ms / 1000.0).toFixed(2) + "s";
    }
    else {
        return ms.toFixed(0) + "ms";
    }
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input, select, label, p {
    font-size: 20px;
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
    padding-right: 5px;
}
</style>

</head>

<body>

<div style="float:left;touch-action:none"><p><canvas id="canvas" width="700" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

<div style="float:left;padding-left: 20px">

<p><label for="recipes_dropdown">Choose a recipe:</label><br><select id="recipes_dropdown" onchange="onRecipeChanged(this)"></select></p>
<p>
  <input type="button" id="zoom_in_button" value="Zoom in" onclick="onZoomInButton(this)" />
  <input type="button" id="zoom_out_button" value="Zoom out" onclick="onZoomOutButton(this)" />
</p>
<p><input type="button" id="hq_mode_button" value="High quality mode: OFF" onclick="onHighQualityModeButton(this)" /></p>
<p><label for="maximum_depth_input">Max search depth:</label>
<input type="number" id="maximum_depth_input" min="1" max="500" value="25" size="4" onchange="onMaxDepthChanged(this)"></p>
<p><label for="epsilon_input">Epsilon:</label><input type="number" id="epsilon_input" min="0" max="10" value="0.01" step="0.001" size="10" onchange="onEpsilonChanged(this)"></p>
<p><label for="which_method_dropdown">Drawing method:</label><select id="which_method_dropdown" onchange="onWhichMethodChanged(this)">
  <option>IFS</option>
  <option>DFS</option>
  <option>both</option>
</select></p>
<p><input type="button" value="Draw control points: ON" onclick="onDrawControlPointsButton(this)" /></p>
<p><label for="which_solution_dropdown">Which solution to plot:</label><select id="which_solution_dropdown" onchange="onWhichSolutionChanged(this)">
  <option>a</option>
  <option>b</option>
  <option>both</option>
</select></p>
<p id="num_points_text"></p>
<p id="rendering_text"></p>
<p>
  <input type="button" id="download_png_button" value="Save as PNG" onclick="onSaveAsPNGButton(this)" />
  <input type="button" id="download_svg_button" value="Save as SVG" onclick="onSaveAsSVGButton(this)" />
</p>

</div>

<div style="clear:both">

<p id="description_text"></p>

<p>This is work in progress. Get in touch if you have questions.</p>

<p>The image shows the points generated by an <a href="https://en.wikipedia.org/wiki/Iterated_function_system">IFS</a> using four <a href="index.html">Möbius transformations</a>. Try dragging the control points around.</p>

<p>See the book Indra's Pearls for details of what this is about. See <a href="ifs.html">this page</a> for a more general Möbius-IFS system.</p>

<hr>

<p>Source code: <a href="https://github.com/timhutton/mobius-transforms">https://github.com/timhutton/mobius-transforms</a></p>

</div>

</html>
