<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="code/math.js"></script>
<script src="code/recipes.js"></script>
<script>

function toScreen( p ) {
    return add( origin_screen, complex_conjugate( mul( p, scale ) ) );
}

function fromScreen( p ) {
    return mul( complex_conjugate( sub( p, origin_screen ) ), 1.0 / scale );
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onTouchMove( evt ) {
    if( point_is_being_dragged )
        evt.preventDefault();
    onMove( fixTouch( evt.changedTouches[0] ) );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        control_points[ i_point ] = fromScreen( add( pos, drag_offset ) );
        compute_and_redraw();
    }
    else {
        // find the closest point, if within a minimum radius
        var iClosest = -1;
        var closest_dist2 = touch_radius * touch_radius;
        var num_control_points = control_points.length;
        for( var i = 0; i < num_control_points; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                closest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            draw();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            draw();
        }
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    onDown( fixTouch( evt.changedTouches[0] ) );
}

function onDown( pos ) {
    // find the closest point, if within a minimum radius
    var iClosest = -1;
    var closest_dist2 = touch_radius * touch_radius;
    var num_control_points = control_points.length;
    for( var i = 0; i < num_control_points; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            closest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        drag_offset = sub( toScreen( control_points[ i_point ] ), pos );
        draw();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        draw();
    }
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        draw();
    }
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        draw();
    }
    is_mouse_down = false;
}

// thanks to: http://stackoverflow.com/a/12714084/126823
function fixTouch (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
        // iOS4 clientX/clientY have the value that should have been
        // in pageX/pageY. While pageX/page/ have the value 0
        x = x - winPageX;
        y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX) ) {
        // Some Android browsers have totally bogus values for clientX/Y
        // when scrolling/zooming a page. Detectable since clientX/clientY
        // should never be smaller than pageX/pageY minus page scroll
        x = touch.pageX - winPageX;
        y = touch.pageY - winPageY;
    }
    var rect = canvas.getBoundingClientRect();
    return p2( x - rect.left, y - rect.top );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    canvas.addEventListener( 'touchend',  onMouseUp, false );
    canvas.addEventListener( 'touchcancel',  onMouseUp, false );

    origin_screen = p2( canvas.width/2, canvas.height/2 );
    scale = Math.min( canvas.width, canvas.height ) / 4.5;

    point_is_highlighted = false;
    point_is_being_dragged = false;
    i_point = -1;
    grab_offset = p2( 0, 0 );

    touch_radius = 50;

    draw_control_points = true;

    // initialise the recipes
    recipes = get_recipes();
    var recipes_dropdown = document.getElementById('recipes_dropdown');
    for( var i = 0; i < recipes.length; i++ ) {
        var el = document.createElement("option");
        el.textContent = recipes[i].label;
        el.value = recipes[i].label;
        recipes_dropdown.appendChild(el);
    }
    iRecipe = 6;
    recipes_dropdown.selectedIndex = iRecipe;

    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    image = ctx.getImageData(0, 0, canvas.width, canvas.height);
    pixels = image.data;

    plot_solution = [ true, true ];
    document.getElementById("which_solution_dropdown").selectedIndex = 2;

    plot_ifs = false;
    plot_dfs = true;
    document.getElementById("which_method_dropdown").selectedIndex = 1;

    hq_mode = false;
    set_quality_parameters( hq_mode );

    compute_and_redraw();
}

function drawPoint( p, r, t, t_offset ) {
    ctx.beginPath();
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI );
    ctx.fillText( t, p.x + t_offset.x - 5, p.y - t_offset.y );
    ctx.fill();
}

function draw(output_pts) {

    // draw the computed image
    ctx.putImageData(image, 0, 0);

    // draw the axes
    if( draw_control_points ) {
        var extent = 6;
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.beginPath();
        drawLine( p2( -extent, 0 ), p2( extent, 0 ) );
        drawLine( p2( 0, -extent ), p2( 0, extent ) );
        // unit marks
        for( var i = -extent; i <= extent; i++ ) {
            drawLine( p2( i, -0.05 ), p2( i, 0.05 ) );
            drawLine( p2( -0.05, i ), p2( 0.05, i ) );
        }
        ctx.stroke();
    }

    // draw the control points
    if( draw_control_points ) {
        ctx.font="22px Arial";
        var rest_color = "rgb(255,255,255)";
        var highlighted_color = "rgb(0,255,255)";
        var dragging_color = "rgb(0,255,0)";
        for( var i = 0; i < control_points.length; i++ ) {
            if( point_is_highlighted && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = highlighted_color;
            else if( point_is_being_dragged && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = dragging_color;
            else
                ctx.fillStyle = ctx.strokeStyle = rest_color;
            var radius = 4;
            var offset = p2( 20.0 * Math.cos(i * Math.PI), 20.0 * Math.sin(i * Math.PI) );
            drawPoint( toScreen( control_points[ i ] ), radius, recipes[ iRecipe ].pt_labels[i], offset );
        }
    }
}

function drawLine( a, b ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    ctx.moveTo( sa.x, sa.y );
    ctx.lineTo( sb.x, sb.y );
}

function onDrawControlPointsButton(element) {
    draw_control_points = !draw_control_points;
    element.value = draw_control_points ? "Draw control points: ON" : "Draw control points: OFF";
    draw();
}

function onRecipeChanged(element) {
    iRecipe = recipes_dropdown.selectedIndex;
    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }
    compute_and_redraw();
}

function set_quality_parameters(hq_mode) {
    if( hq_mode ) {
        num_ifs_iterations = 10000000;
        inc = 1;
        max_depth = 50;
        closeness_epsilon = 0.001; // if sequential points are closer than this we can stop searching
    }
    else {
        num_ifs_iterations = 100000;
        inc = 100;
        max_depth = 15;
        closeness_epsilon = 0.003; // if sequential points are closer than this we can stop searching
    }
    closeness_epsilon2 = closeness_epsilon * closeness_epsilon;
}

function onHighQualityModeButton(element) {
    hq_mode = !hq_mode;
    element.value = hq_mode ? "High quality mode: ON" : "High quality mode: OFF";
    set_quality_parameters( hq_mode );
    compute_and_redraw();
}

function onWhichSolutionChanged(element) {
    plot_solution[0] = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_solution[1] = element.selectedIndex == 1 || element.selectedIndex == 2;
    compute_and_redraw();
}

function onWhichMethodChanged(element) {
    plot_ifs = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_dfs = element.selectedIndex == 1 || element.selectedIndex == 2;
    compute_and_redraw();
}

function download(filename, type, text) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:'+type+';charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

function getBounds(pts) {
    var bounds = { minX: Number.MAX_VALUE, minY: Number.MAX_VALUE, maxX: -Number.MAX_VALUE, maxY: -Number.MAX_VALUE };
    for( var i = 0; i < pts.length; i++) {
        if( pts[i].x < bounds.minX) { bounds.minX = pts[i].x; }
        if( pts[i].y < bounds.minY) { bounds.minY = pts[i].y; }
        if( pts[i].x > bounds.maxX) { bounds.maxX = pts[i].x; }
        if( pts[i].y > bounds.maxY) { bounds.maxY = pts[i].y; }
    }
    bounds.width = bounds.maxX - bounds.minX;
    bounds.height = bounds.maxY - bounds.minY;
    return bounds;
}

function onSaveAsSVGButton(element) {
    var bounds = getBounds(output_pts);
    var svg = "<!-- SVG produced by https://github.com/timhutton/mobius-transforms -->\n";
    svg += "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' width='"+bounds.width.toFixed(1)+"px' height='"+bounds.height.toFixed(1)+"px' viewBox='"
        + bounds.minX.toFixed(1) + " " + bounds.minY.toFixed(1) + " " + bounds.width.toFixed(1) + " " + bounds.height.toFixed(1) + "'>\n";
    svg += "  <polygon points='";
    for( var iPt = 0; iPt < output_pts.length; iPt++) {
        svg += output_pts[iPt].x.toFixed(3) + ", " + output_pts[iPt].y.toFixed(3) + " "
    }
    svg += "'\n    fill='none' stroke='black' stroke-width='0.3'/>\n";
    svg += "</svg>\n";
    download("dfs.svg", "image/svg+xml", svg);
}

function onSaveAsPNGButton(element) {
    var max_image_dimension = 3000;
    var bounds = getBounds(output_pts);
    var scale = max_image_dimension / Math.max( bounds.width, bounds.height );
    var width = bounds.width * scale;
    var height = bounds.height * scale;
    var border = 5;
    // create a large canvas
    var new_canvas = document.createElement('canvas');
    new_canvas.width = width + border * 2;
    new_canvas.height = height + border * 2;
    var context = new_canvas.getContext('2d');
    context.fillStyle = 'rgb(255,255,255)';
    context.fillRect(0, 0, new_canvas.width, new_canvas.height);
    // draw the whole loop
    context.strokeStyle = 'rgba(0,0,0,1.0)';
    context.fillStyle = 'rgba(247, 246, 216, 1.0)';
    context.beginPath();
    var sp0 = add( mul( sub( output_pts[0], p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border ) );
    context.moveTo( sp0.x, sp0.y );
    for(var i = 1; i < output_pts.length; i++) {
        var sp = add( mul( sub( output_pts[i], p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border) );
        context.lineTo( sp.x, sp.y );
    }
    context.lineTo( sp0.x, sp0.y );
    context.stroke();
    context.fill();
    // save the png
    var downloadLink = document.createElement('a');
    downloadLink.download = 'dfs.png';
    downloadLink.href = new_canvas.toDataURL();
    downloadLink.click();
}

function compute_and_redraw() {
    document.getElementById('rendering_text').textContent = "Rendering...";
    setTimeout(function() {
        clear_drawing();
        output_pts = compute();
        draw(output_pts);
    }, 1 );
}

function clear_drawing() {
    for( var i = 0; i < image.width * image.height; i++) {
        image.data[ i*4 + 0 ] = 0;
        image.data[ i*4 + 1 ] = 0;
        image.data[ i*4 + 2 ] = 0;
        image.data[ i*4 + 3 ] = 255;
    }
}

function line(x0, y0, x1, y1, func) {
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    var sx = (x0 < x1) ? 1 : -1;
    var sy = (y0 < y1) ? 1 : -1;
    var err = dx - dy;

    while(true) {
        func(x0, y0);
        if ((x0 === x1) && (y0 === y1)) break;
        var e2 = 2*err;
        if (e2 > -dy) { err -= dy; x0  += sx; }
        if (e2 < dx) { err += dx; y0  += sy; }
    }
}

function format_complex( a ) {
    return `${ a.x.toFixed(3) } ${ a.y >= 0.0 ? "+" : "-" } ${ Math.abs(a.y).toFixed(3) }i`;
}

function make_generators(which_solution) {
    // construct the four Mobius transformations we will be using
    var [transforms, description] = recipes[ iRecipe ].make_generators(which_solution, control_points);
    transforms[2] = get_mobius_inverse( transforms[0] );
    transforms[3] = get_mobius_inverse( transforms[1] );
    return [transforms, description];
}

function draw_image_line( a, b, rgb, output_pts ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    if( sa.x >= 0 && sa.y >=0 && sa.x < image.width && sa.y < image.height &&
        sb.x >= 0 && sb.y >=0 && sb.x < image.width && sb.y < image.height) {
        line( Math.floor(sa.x), Math.floor(sa.y), Math.floor(sb.x), Math.floor(sb.y), (sx, sy) => {
            var pixel_offset = ( sy * image.width + sx ) * 4;
            pixels[pixel_offset + rgb] = 255;
        } );
        output_pts.push( toScreen( mul( sa, 1.5 ) ) );
        output_pts.push( toScreen( mul( sb, 1.5 ) ) );
    }
}

function plot_dfs_fix(transforms, max_d2, rgb, output_pts) {
    var fix = [];
    for(var i = 0; i < transforms.length; i++) {
        fix[i] = get_mobius_fixed_points( transforms[i] )[0];
    }
    var n_pts_plotted = 0;
    var max_pts = 1e6; // need to stop the app becoming unresponsive
    var old_p, old_sp;
    var have_old_p = false;
    function explore_tree( x, prev, level ) {
        var n_pts = 0;
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTransform = (k + 4) % 4;
            var y = get_mobius_composed( x, transforms[iTransform] )
            var p = mobius_on_point( y, fix[iTransform] );
            if( level > 0 && n_pts < max_pts && ( !have_old_p || dist2(p, old_p) > closeness_epsilon2 ) ) {
                var ret = explore_tree( y, iTransform, level-1 );
                if( ret == -1 ) {
                    return -1; // continue abort
                }
                n_pts += ret;
            }
            else {
                var sp = toScreen( p );
                if( have_old_p ) {
                    if( dist2(p, old_p) > max_d2 ) {
                        // abort: lines are too long
                        return -1;
                    }
                    // draw line
                    if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height &&
                        old_sp.x >= 0 && old_sp.y >=0 && old_sp.x < image.width && old_sp.y < image.height) {
                        line( Math.floor(old_sp.x), Math.floor(old_sp.y), Math.floor(sp.x), Math.floor(sp.y), (sx, sy) => {
                            var pixel_offset = ( sy * image.width + sx ) * 4;
                            pixels[pixel_offset + rgb] = 255;
                        } );
                        output_pts.push( mul( sp, 1.5 ) );
                    }
                }
                old_p = p;
                old_sp = sp;
                have_old_p = true;
                n_pts++;
            }
        }
        return n_pts;
    };
    for( var k = 0; k < 4; k++) {
        var ret = explore_tree( transforms[k], k, max_depth );
        if( ret >= 0 ) {
            n_pts_plotted += ret;
        }
    }
    return n_pts_plotted;
}

function plot_dfs_endpts(transforms, max_d2, rgb, output_pts) {
    var endpt = [
        get_mobius_fixed_points( get_mobius_composed( transforms[3], get_mobius_composed( transforms[2], get_mobius_composed( transforms[1], transforms[0] ) ) ) )[0],
        get_mobius_fixed_points( get_mobius_composed( transforms[0], get_mobius_composed( transforms[3], get_mobius_composed( transforms[2], transforms[1] ) ) ) )[0],
        get_mobius_fixed_points( get_mobius_composed( transforms[1], get_mobius_composed( transforms[0], get_mobius_composed( transforms[3], transforms[2] ) ) ) )[0],
        get_mobius_fixed_points( get_mobius_composed( transforms[2], get_mobius_composed( transforms[1], get_mobius_composed( transforms[0], transforms[3] ) ) ) )[0]
    ];
    var n_pts_plotted = 0;
    var max_pts = 1e6; // need to stop the app becoming unresponsive
    var old_p, old_sp;
    var have_old_p = false;
    function explore_tree( x, prev, level ) {
        var n_pts = 0;
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTransform = (k + 4) % 4;
            var y = get_mobius_composed( x, transforms[iTransform] )
            var p = mobius_on_point( y, endpt[iTransform] );
            if( level > 0 && n_pts < max_pts && ( !have_old_p || dist2(p, old_p) > closeness_epsilon2 ) ) {
                var ret = explore_tree( y, iTransform, level-1 );
                if( ret == -1 ) {
                    return -1; // continue abort
                }
                n_pts += ret;
            }
            else {
                var sp = toScreen( p );
                if( have_old_p ) {
                    if( dist2(p, old_p) > max_d2 ) {
                        // abort: lines are too long
                        return -1;
                    }
                    // draw line
                    if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height &&
                        old_sp.x >= 0 && old_sp.y >=0 && old_sp.x < image.width && old_sp.y < image.height) {
                        line( Math.floor(old_sp.x), Math.floor(old_sp.y), Math.floor(sp.x), Math.floor(sp.y), (sx, sy) => {
                            var pixel_offset = ( sy * image.width + sx ) * 4;
                            pixels[pixel_offset + rgb] = 255;
                        } );
                        output_pts.push( mul( sp, 1.5 ) );
                    }
                }
                old_p = p;
                old_sp = sp;
                have_old_p = true;
                n_pts++;
            }
        }
        return n_pts;
    };
    for( var k = 0; k < 4; k++) {
        var ret = explore_tree( transforms[k], k, max_depth );
        if( ret >= 0 ) {
            n_pts_plotted += ret;
        }
    }
    return n_pts_plotted;
}

function compose4(a,b,c,d) {
    return get_mobius_composed( a, get_mobius_composed( b, get_mobius_composed( c, d ) ) );
}

function plot_dfs_repetends(transforms, max_d2, rgb, output_pts) {
    var n_pts_plotted = 0;
    // define the repetends
    var [ a, b, A, B ] = transforms;
    var bABa = compose4(b, A, B, a);
    var BAba = compose4(B, A, b, a);
    var ABab = compose4(A, B, a, b);
    var aBAb = compose4(a, B, A, b);
    var BabA = compose4(B, a, b, A);
    var baBA = compose4(b, a, B, A);
    var abAB = compose4(a, b, A, B);
    var AbaB = compose4(A, b, A, B);
    var repetends = [ [ bABa, a, BAba ], [ ABab, b, aBAb ], [ BabA, A, baBA ], [ abAB, B, AbaB ] ]; // p. 218
    var fp = [];
    for( var i = 0; i < 4; i++) {
        fp.push( [] );
        for( var j = 0; j < 3; j++) {
            fp[i].push( get_mobius_fixed_points( repetends[i][j] )[0] ); // Fix+ for each repetend
        }
    }
    function explore_tree( transforms, x, prevTransform, level, fp, max_d2, rgb, output_pts ) {
        var n_pts = 0;
        for( var k = prevTransform - 1; k <= prevTransform + 1; k++) {
            var iTransform = (k + 4) % 4;
            var y = get_mobius_composed( x, transforms[iTransform] )
            var z1 = mobius_on_point( y, fp[iTransform][0] );
            var z2 = mobius_on_point( y, fp[iTransform][1] );
            var z3 = mobius_on_point( y, fp[iTransform][2] );
            var d2_z2_z1 = dist2( z2, z1 );
            var d2_z3_z2 = dist2( z3, z2 );
            var close_enough = d2_z2_z1 < closeness_epsilon2 && d2_z3_z2 < closeness_epsilon2;
            if( level < max_depth && !close_enough ) {
                var ret = explore_tree( transforms, y, iTransform, level+1, fp, max_d2, rgb, output_pts );
                if( ret == -1 ) { return -1; } // abort
                n_pts += ret;
            }
            else {
                if( d2_z2_z1 > max_d2 || d2_z3_z2 > max_d2 ) {
                    return -1; // immediate abort, have hit a bad region
                }
                draw_image_line( z1, z2, rgb, output_pts );
                draw_image_line( z2, z3, rgb, output_pts );
                n_pts++;
            }
        }
        return n_pts;
    };
    for( var k = 0; k < 4; k++) {
        var ret = explore_tree( transforms, transforms[k], k, 0, fp, max_d2, rgb, output_pts );
        if( ret >= 0 ) { n_pts_plotted += ret; }
    }
    return n_pts_plotted;
}

function draw_ifs(transforms, rgb) {
    var p = p2(0.0,0.0);
    for( var i = 0; i < num_ifs_iterations; i++) {
        p = mobius_on_point( transforms[Math.floor(Math.random() * transforms.length)], p );
        var sp = toScreen( p );
        if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height ) {
            var pixel_offset = ( Math.floor(sp.y) * image.width + Math.floor(sp.x) ) * 4;
            // sort of log-mapping: pixels get brighter at a slower rate the brighter they get,
            // avoids saturating too quickly
            var val = pixels[pixel_offset + rgb];
            if( Math.random() > val / 255.0 ) {
                pixels[pixel_offset + rgb] = Math.min( 255, val + inc );
            }
        }
    }
    return num_ifs_iterations;
}

function compute() {

    const time_start = performance.now();

    var n_pts_plotted = 0;
    var output_pts = [];
    var max_d2 = 1.0; // abort if any line is longer than this
    var transforms = [];
    var description = "";

    if( plot_dfs ) {
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators(which_solution);

            //n_pts_plotted += plot_dfs_fix( transforms, max_d2, which_solution, output_pts );
            n_pts_plotted += plot_dfs_endpts( transforms, max_d2, which_solution, output_pts );
            //n_pts_plotted += plot_dfs_repetends( transforms, max_d2, which_solution, output_pts );
        }
    }

    if(n_pts_plotted == 0) {
        // DFS rendering failed, clear the drawing and draw IFS instead
        clear_drawing();
    }

    if(n_pts_plotted == 0 || plot_ifs) {
        // run IFS
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators(which_solution);

            n_pts_plotted += draw_ifs(transforms, which_solution);
        }
    }

    const time_end = performance.now();
    const ms_elapsed = time_end - time_start;
    if( ms_elapsed > 1000.0 ) {
        document.getElementById('rendering_text').textContent = "Last render took: "+ms_elapsed/1000+"s";
    }
    else {
        document.getElementById('rendering_text').textContent = "Last render took: "+ms_elapsed+"ms";
    }
    if( n_pts_plotted > 0 ) {
        document.getElementById('num_points_text').textContent = "Number of points: " + n_pts_plotted;
    }
    else {
        document.getElementById('num_points_text').textContent = "Aborted rendering";
    }
    document.getElementById('download_svg_button').disabled = ( output_pts.length == 0 );
    document.getElementById('download_png_button').disabled = ( output_pts.length == 0 );
    document.getElementById('description_text').textContent = "Description: " + description;

    return output_pts;
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input[type='button'], select, label, p {
    font-size: 20px;
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
    padding-right: 5px;
}
</style>

</head>

<body>

<div style="float:left;touch-action:none"><p><canvas id="canvas" width="700" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

<div style="float:left;padding-left: 20px">

<p><label for="recipes_dropdown">Choose a recipe:</label><br><select id="recipes_dropdown" onchange="onRecipeChanged(this)"></select></p>
<p><input type="button" id="hq_mode_button" value="High quality mode: OFF" onclick="onHighQualityModeButton(this)" /></p>
<p><label for="which_method_dropdown">Drawing method:</label><select id="which_method_dropdown" onchange="onWhichMethodChanged(this)">
  <option>IFS</option>
  <option>DFS</option>
  <option>both</option>
</select></p>
<p><input type="button" value="Draw control points: ON" onclick="onDrawControlPointsButton(this)" /></p>
<p><label for="which_solution_dropdown">Which solution to plot:</label><select id="which_solution_dropdown" onchange="onWhichSolutionChanged(this)">
  <option>a</option>
  <option>b</option>
  <option>both</option>
</select></p>
<p id="num_points_text"></p>
<p id="rendering_text"></p>
<p><input type="button" id="download_png_button" value="Save as PNG" onclick="onSaveAsPNGButton(this)" /></p>
<p><input type="button" id="download_svg_button" value="Save as SVG" onclick="onSaveAsSVGButton(this)" /></p>

</div>

<div style="clear:both">

<p id="description_text"></p>

<p>This is work in progress. Get in touch if you have questions.</p>

<p>The image shows the points generated by an <a href="https://en.wikipedia.org/wiki/Iterated_function_system">IFS</a> using four <a href="index.html">Möbius transformations</a>. Try dragging the control points around.</p>

<p>See the book Indra's Pearls for details of what this is about. See <a href="ifs.html">this page</a> for a more general Möbius-IFS system.</p>

<hr>

<p>Source code: <a href="https://github.com/timhutton/mobius-transforms">https://github.com/timhutton/mobius-transforms</a></p>

</div>

</html>
