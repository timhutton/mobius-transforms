<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="code/math.js"></script>
<script>

function toScreen( p ) {
    return add( origin_screen, complex_conjugate( mul( p, scale ) ) );
}

function fromScreen( p ) {
    return mul( complex_conjugate( sub( p, origin_screen ) ), 1.0 / scale );
}

function inViewingFrustrum( p ) {
    return true;
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onTouchMove( evt ) {
    if( point_is_being_dragged )
        evt.preventDefault();
    onMove( fixTouch( evt.changedTouches[0] ) );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        control_points[ i_point ] = fromScreen( add( pos, drag_offset ) );
        if(hq_mode) {
            document.getElementById('hq_mode_button').value = "Rendering...";
        }
        setTimeout(() => { // (delay to allow the button text to update)
                clearIFS();
                runIFS();
                draw();
                if(hq_mode) {
                    document.getElementById('hq_mode_button').value = "High quality mode: ON";
                }
            }, 1);
    }
    else {
        // find the closest point, if within a minimum radius
        var iClosest = -1;
        var closest_dist2 = touch_radius * touch_radius;
        var num_control_points = control_points.length;
        for( var i = 0; i < num_control_points; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                closest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            draw();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            draw();
        }
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    onDown( fixTouch( evt.changedTouches[0] ) );
}

function onDown( pos ) {
    // find the closest point, if within a minimum radius
    var iClosest = -1;
    var closest_dist2 = touch_radius * touch_radius;
    var num_control_points = control_points.length;
    for( var i = 0; i < num_control_points; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            closest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        drag_offset = sub( toScreen( control_points[ i_point ] ), pos );
        draw();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        draw();
    }
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        draw();
    }
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        draw();
    }
    is_mouse_down = false;
}

// thanks to: http://stackoverflow.com/a/12714084/126823
function fixTouch (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
        // iOS4 clientX/clientY have the value that should have been
        // in pageX/pageY. While pageX/page/ have the value 0
        x = x - winPageX;
        y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX) ) {
        // Some Android browsers have totally bogus values for clientX/Y
        // when scrolling/zooming a page. Detectable since clientX/clientY
        // should never be smaller than pageX/pageY minus page scroll
        x = touch.pageX - winPageX;
        y = touch.pageY - winPageY;
    }
    var rect = canvas.getBoundingClientRect();
    return p2( x - rect.left, y - rect.top );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    canvas.addEventListener( 'touchend',  onMouseUp, false );
    canvas.addEventListener( 'touchcancel',  onMouseUp, false );

    velocities = [];
    for(var i = 0; i < 10; i++) {
        var dir = Math.random() * 2.0 * Math.PI;
        velocities.push( p2( Math.cos( dir ) * 0.005, Math.sin( dir ) * 0.005 ) );
    }

    origin_screen = p2( canvas.width/2, canvas.height/2 );
    scale = Math.min( canvas.width, canvas.height ) / 4.5;

    point_is_highlighted = false;
    point_is_being_dragged = false;
    i_point = -1;
    grab_offset = p2( 0, 0 );

    touch_radius = 50;

    draw_control_points = true;

    // initialise the recipes
    theta_schottky = { label: "\u03B8-Schottky", control_points: [ p2(0.6, 0.5) ], pt_labels: [ '\u03B8' ] };
    gasket = { label: "gasket", control_points: [] };
    maskit = { label: "Maskit parameterization", control_points: [ p2(2.0, 0.0), p2(2.0, 0.0) ], pt_labels: [ 't', 'k' ] };
    grandma = {
        label: "Grandma's recipe",
        control_points: [ p2(2.4, 0.0), p2(2.4, 0.0) ],
        //control_points: [ p2(1.87, 0.1), p2(1.87, -0.1) ],
        pt_labels: [ 'ta', 'tb' ] };
    riley = { label: "Riley's recipe", control_points: [ p2(0.05, 0.93) ], pt_labels: [ 'c' ] };
    jorgensen = { label: "Jorgensen's recipe", control_points: [ p2(1.87, 0.1), p2(1.87, -0.1) ], pt_labels: [ 'ta', 'tb' ] };
    special = { label: "Grandma's four-alarm special", control_points: [ p2(1.87, -0.08), p2(1.87, 0.1), p2(-1.87, 0.05) ], pt_labels: [ 'ta', 'tb', 't_ab' ] };
    recipes = [ theta_schottky, gasket, maskit, grandma, riley, jorgensen, special ];
    var recipes_dropdown = document.getElementById('recipes_dropdown');
    for( var i = 0; i < recipes.length; i++ ) {
        var el = document.createElement("option");
        el.textContent = recipes[i].label;
        el.value = recipes[i].label;
        recipes_dropdown.appendChild(el);
    }

    // default recipe:
    iRecipe = 3;
    recipes_dropdown.selectedIndex = iRecipe;
    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    image = ctx.getImageData(0, 0, canvas.width, canvas.height);
    pixels = image.data;

    hq_mode = false;
    num_ifs_iterations = 100000;
    inc = 100;
    clearIFS();
    runIFS();

    draw();

    move_points = false;
    animate();
}

function drawPoint( p, r, t, t_offset ) {
    ctx.beginPath();
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI );
    ctx.fillText( t, p.x + t_offset.x - 5, p.y - t_offset.y );
    ctx.fill();
}

function draw() {

    // draw ifs
    ctx.putImageData(image, 0, 0);

    var extent = 6;

    // draw the axes
    if( draw_control_points ) {
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.beginPath();
        drawLine( p2( -extent, 0 ), p2( extent, 0 ) );
        drawLine( p2( 0, -extent ), p2( 0, extent ) );
        // unit marks
        for( var i = -extent; i <= extent; i++ ) {
            drawLine( p2( i, -0.05 ), p2( i, 0.05 ) );
            drawLine( p2( -0.05, i ), p2( 0.05, i ) );
        }
        ctx.stroke();
    }

    // draw the control points
    if( draw_control_points ) {
        ctx.font="22px Arial";
        var rest_color = "rgb(255,255,255)";
        var highlighted_color = "rgb(0,255,255)";
        var dragging_color = "rgb(0,255,0)";
        var num_moveable_control_points = control_points.length;
        for( var i = 0; i < control_points.length; i++ ) {
            if( point_is_highlighted && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = highlighted_color;
            else if( point_is_being_dragged && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = dragging_color;
            else
                ctx.fillStyle = ctx.strokeStyle = rest_color;
            var radius = ( i < num_moveable_control_points ) ? 4 : 2;
            var offset = p2( 20.0 * Math.cos(i * Math.PI), 20.0 * Math.sin(i * Math.PI) );
            drawPoint( toScreen( control_points[ i ] ), radius, recipes[ iRecipe ].pt_labels[i], offset );
        }
    }

    // draw fixed points?
    if( false ) {
        ctx.fillStyle = ctx.strokeStyle = "rgb(255, 255, 255)";
        var f_plus, f_minus;
        for( var i = 0; i < transforms.length; i++ ) {
            [ f_plus, f_minus ] = get_mobius_fixed_points( transforms[i] );
            drawPoint( toScreen( f_plus ), 2, "f+", p2(0,0) );
            drawPoint( toScreen( f_minus ), 2, "f-", p2(0,0) );
        }
    }
}

function drawLine( a, b ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    ctx.moveTo( sa.x, sa.y );
    ctx.lineTo( sb.x, sb.y );
}

function onDrawControlPointsButton(element) {
    draw_control_points = !draw_control_points;
    element.value = draw_control_points ? "Draw control points: ON" : "Draw control points: OFF";
    draw();
}

function onHighQualityModeButton(element) {
    hq_mode = !hq_mode;
    element.value = hq_mode ? "High quality mode: ON" : "High quality mode: OFF";
    if( hq_mode ) {
        num_ifs_iterations = 100000000;
        inc = 1;
    }
    else {
        num_ifs_iterations = 100000;
        inc = 100;
    }
    if(hq_mode) {
        element.value = "Rendering...";
    }
    setTimeout(() => { // (delay to allow the button text to update)
            clearIFS();
            runIFS();
            draw();
            if(hq_mode) {
                element.value = "High quality mode: ON";
            }
        }, 1);
}

function onAnimateModeButton(element) {
    move_points = !move_points;
    element.value = move_points ? "Animate control points: ON" : "Animate control points: OFF";
    draw();
    if( move_points) {
        animate();
    }
}

function onRecipeChanged(element) {
    iRecipe = recipes_dropdown.selectedIndex;
    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }
    clearIFS();
    runIFS();
    draw();
}

function animate( currentFrameTime ) {
    if( move_points ) {
        for( var i = 0; i < control_points.length; i++) {
            control_points[i] = add( control_points[i], velocities[i] );
            if( control_points[i].x < -2 ) {
                control_points[i].x = -4.0 - control_points[i].x;
                velocities[i].x *= -1.0;
            }
            else if( control_points[i].x > 2 ) {
                control_points[i].x = 4.0 - control_points[i].x;
                velocities[i].x *= -1.0;
            }
            if( control_points[i].y < -2 ) {
                control_points[i].y = -4.0 - control_points[i].y;
                velocities[i].y *= -1.0;
            }
            else if( control_points[i].y > 2 ) {
                control_points[i].y = 4.0 - control_points[i].y;
                velocities[i].y *= -1.0;
            }
        }
        clearIFS();
        runIFS();
        draw();
        requestAnimationFrame( animate );
    }
}

function clearIFS() {
    for( var i = 0; i < image.width * image.height; i++) {
        image.data[ i*4 + 0 ] = 0;
        image.data[ i*4 + 1 ] = 0;
        image.data[ i*4 + 2 ] = 0;
        image.data[ i*4 + 3 ] = 255;
    }
}

function line(x0, y0, x1, y1, func) {
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    var sx = (x0 < x1) ? 1 : -1;
    var sy = (y0 < y1) ? 1 : -1;
    var err = dx - dy;

    while(true) {
        func(x0, y0);
        if ((x0 === x1) && (y0 === y1)) break;
        var e2 = 2*err;
        if (e2 > -dy) { err -= dy; x0  += sx; }
        if (e2 < dx) { err += dx; y0  += sy; }
    }
}

function runIFS() {

    // for recipes that use a solution of a quadratic equation, we don't know which one to use, so use both
    for( var which_solution = 0; which_solution < 2; which_solution++ ) {

        // construct the four Mobius transformations we will be using
        transforms = []; // order will be: a, b, A, B
        var recipe = recipes[ iRecipe ];
        if( recipe == theta_schottky ) {
            // Indra's Pearls, page 118
            var theta = Math.atan2( control_points[0].y, control_points[0].x );
            var sin_theta = Math.sin( theta );
            var cos_theta = Math.cos( theta );
            transforms[0] = [ p2( 1.0 / sin_theta, 0.0 ), p2( 0.0, cos_theta / sin_theta), p2( 0.0, -cos_theta / sin_theta ), p2( 1.0 / sin_theta, 0.0 ) ];
            transforms[1] = [ p2( 1.0 / sin_theta, 0.0 ), p2( cos_theta / sin_theta, 0.0 ), p2( cos_theta / sin_theta, 0.0 ), p2( 1.0 / sin_theta, 0.0 ) ];
        }
        else if( recipe == gasket ) {
            transforms[0] = [ p2( 1.0, 0.0 ), p2( 0.0, 0.0), p2( 0.0, -2.0 ), p2( 1.0, 0.0 ) ];
            transforms[1] = [ p2( 1.0, -1.0 ), p2( 1.0, 0.0 ), p2( 1.0, 0.0 ), p2( 1.0, 1.0 ) ];
        }
        else if( recipe == maskit ) {
            // Following Jos Ley's paper: http://www.josleys.com/articles/Kleinian%20escape-time_3.pdf
            var t = control_points[0];
            var k = control_points[1];
            transforms[0] = [ t, p2(0.0, -1.0), p2(0.0, -1.0), p2(0.0, 0.0) ];     // a: z -> (tz-i)/(-iz)
            transforms[1] = [ p2(1.0, 0.0), k, p2(0.0, 0.0),  p2(1.0, 0.0) ];      // b: z -> z + k
        }
        else if( recipe == grandma ) {
            // Indra's Pearls, p. 227
            var t_a = control_points[0];
            var t_b = control_points[1];
            // solve x^2 - t_a * t_b * x + t_a^2 + t_b^2 = 0 for x
            var solutions = complex_solve_quadratic( p2( 1.0, 0.0 ), mul( mul_complex( t_a, t_b ), -1.0 ), add( mul_complex( t_a, t_a ), mul_complex( t_b, t_b ) ) );
            var t_ab = solutions[which_solution]; // pick one
            var z0 = div_complex( mul_complex( sub( t_ab, p2( 2.0, 0.0 ) ), t_b ),
                                  add( sub( mul_complex( t_b, t_ab ), mul( t_a, 2.0 ) ), mul_complex( p2( 0.0, 2.0 ), t_ab ) ) );
            transforms[0] = [ mul( t_a, 0.5 ),
                              div_complex( add( sub( mul_complex( t_a, t_ab ), mul( t_b, 2.0 ) ), p2( 0.0, 4.0 ) ), mul_complex( add( mul( t_ab, 2.0 ), p2( 4.0, 0.0 ) ), z0 ) ),
                              div_complex( mul_complex( sub( sub( mul_complex( t_a, t_ab ), mul( t_b, 2.0 ) ), p2( 0.0, 4.0 ) ), z0 ), sub( mul( t_ab, 2.0 ), p2( 4.0, 0.0 ) ) ),
                              mul( t_a, 0.5 ) ];
            transforms[1] = [ mul( sub( t_b, p2( 0.0, 2.0 ) ), 0.5 ), mul( t_b, 0.5 ), mul( t_b, 0.5 ), mul( add( t_b, p2( 0.0, 2.0 ) ), 0.5 ) ];
        }
        else if( recipe == riley ) {
            // Indra's Pearls, p. 258
            var c = control_points[0];
            transforms[0] = [ p2( 1.0, 0.0 ), p2( 0.0, 0.0 ), c,              p2( 1.0, 0.0 ) ];
            transforms[1] = [ p2( 1.0, 0.0 ), p2( 2.0, 0.0 ), p2( 0.0, 0.0 ), p2( 1.0, 0.0 ) ];
        }
        else if( recipe == jorgensen ) {
            // Indra's Pearls, p. 256
            var t_a = control_points[0];
            var t_b = control_points[1];
            // solve x^2 - t_a * t_b * x + t_a^2 + t_b^2 = 0 for x
            var solutions = complex_solve_quadratic( p2( 1.0, 0.0 ), mul( mul_complex( t_a, t_b ), -1.0 ), add( mul_complex( t_a, t_a ), mul_complex( t_b, t_b ) ) );
            var t_ab = solutions[which_solution]; // pick one
            transforms[0] = [ sub( t_a, div_complex( t_b, t_ab ) ), div_complex( t_a, mul_complex( t_ab, t_ab ) ), t_a, div_complex( t_b, t_ab ) ];
            transforms[1] = [ sub( t_b, div_complex( t_a, t_ab ) ), mul( div_complex( t_b, mul_complex( t_ab, t_ab ) ), -1.0 ), mul( t_b, -1.0 ), div_complex( t_a, t_ab ) ];
        }
        else if( recipe == special ) {
            // Indra's Pearls, p. 260
            // not sure this is working correctly. will need to explore when have better rendering.
            var t_a = control_points[0];
            var t_b = control_points[1];
            var t_ab = control_points[2];
            var t_C = sub( sub( add( add( mul_complex( t_a, t_a ), mul_complex( t_b, t_b ) ), mul_complex( t_ab, t_ab ) ), mul_complex( mul_complex( t_a, t_b ), t_ab ) ), p2(2.0, 0.0) );
            var Q = mul( sqrt_complex( sub( p2( 2.0, 0.0 ), t_C ) ), which_solution==0?1.0:-1.0 );
            var sign = 1.0;
            var sqrt_tc_plus_2 = sqrt_complex( add( t_C, p2( 2.0, 0.0 ) ) );
            if( magnitude( add( t_C, mul_complex( mul_complex( p2( 0.0, 1.0 ), Q ), sqrt_tc_plus_2 ) ) ) < 2.0 ) {
                sign = -1.0;
            }
            var R = mul( sqrt_tc_plus_2, sign );
            var z0 = div_complex( mul_complex( sub( t_ab, p2( 2.0, 0.0 ) ), add( t_b, R ) ), add( sub( mul_complex( t_b, t_ab ), mul( t_a, 2.0 ) ), mul_complex( mul_complex( p2( 0.0, 1.0 ), Q ), t_ab ) ) );
            transforms[0] = [
                mul( t_a, 0.5 ),
                div_complex( add( sub( mul_complex( t_a, t_ab ), mul( t_b, 2.0 ) ), mul_complex( p2( 0.0, 2.0 ), Q ) ), mul_complex( add( mul( t_ab, 2.0 ), p2( 4.0, 0.0 ) ), z0 ) ),
                div_complex( mul_complex( sub( sub( mul_complex( t_a, t_ab ), mul( t_b, 2.0 ) ), mul_complex( p2( 0.0, 2.0 ), Q ) ), z0 ), sub( mul( t_ab, 2.0 ), p2( 4.0, 0.0 ) ) ),
                mul( t_a, 0.5 ) ];
            transforms[1] = [
                mul( sub( t_b, mul_complex( p2( 0.0, 1.0 ), Q ) ), 0.5 ),
                div_complex( sub( sub( mul_complex( t_b, t_ab ), mul( t_a, 2.0 ) ), mul_complex( mul_complex( p2( 0.0, 1.0 ), Q ), t_ab ) ), mul_complex( add( mul( t_ab, 2.0 ), p2( 4.0, 0.0 ) ), z0 ) ),
                div_complex( mul_complex( add( sub( mul_complex( t_b, t_ab ), mul( t_a, 2.0 ) ), mul_complex( mul_complex( p2( 0.0, 1.0 ), Q ), t_ab ) ), z0 ), sub( mul( t_ab, 2.0 ), p2( 4.0, 0.0 ) ) ),
                mul( add( t_b, mul_complex( p2( 0.0, 1.0 ), Q ) ), 0.5 ) ];
        }
        else { throw "Unsupported recipe"; }
        transforms[2] = get_mobius_inverse( transforms[0] );
        transforms[3] = get_mobius_inverse( transforms[1] );

        // run IFS
        if( false ) {
            var p = p2(0.0,0.0);
            for( var i = 0; i < num_ifs_iterations; i++) {
                p = mobius_on_point( transforms[Math.floor(Math.random() * transforms.length)], p );
                var sp = toScreen( p );
                if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height ) {
                    var pixel_offset = ( Math.floor(sp.y) * image.width + Math.floor(sp.x) ) * 4;
                    // sort of log-mapping: pixels get darker at a slower rate the darker they get
                    // avoids saturating too much
                    var val = pixels[pixel_offset + which_solution];
                    if( Math.random() > val / 255.0 ) {
                        pixels[pixel_offset + which_solution] = Math.min( 255, val + inc );
                    }
                }
            }
        }

        // run DFS, Indra's Pearls, p. 152
        {
            var fix = [];
            for(var i = 0; i < 4; i++) {
                fix[i] = get_mobius_fixed_points( transforms[i] )[0]; // Fix+
            }
            var old_p, old_sp;
            var have_old_p = false;
            function explore_tree( x, prev, level ) {
                var n_pts = 0;
                for( var k = prev - 1; k <= prev + 1; k++) {
                    var iTransform = (k + 4) % 4;
                    var y = get_mobius_composed( x, transforms[iTransform] )
                    var p = mobius_on_point( y, fix[iTransform] );
                    //if( !have_old_p ) { old_p = p2( p.x, p.y ); old_sp = toScreen( old_p ); have_old_p = true; }
                    //var circ = mobius_on_circle( y, { p: p2(0.0, 0.0), r:1.0 } ); //l not sure how to get C_a etc. for arbitrary transforms
                    //if( level > 0 && circ.r > 0.002) {
                    if( level > 0 && ( !have_old_p || dist2(p, old_p) > 0.00002 ) ) {
                        n_pts += explore_tree( y, iTransform, level-1 );
                    }
                    else {
                        var sp = toScreen( p );
                        if( have_old_p && dist2(p, old_p) < 0.01 ) {
                            // draw line
                            if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height &&
                                old_sp.x >= 0 && old_sp.y >=0 && old_sp.x < image.width && old_sp.y < image.height) {
                                line( Math.floor(old_sp.x), Math.floor(old_sp.y), Math.floor(sp.x), Math.floor(sp.y), (sx, sy) => {
                                    var pixel_offset = ( sy * image.width + sx ) * 4;
                                    pixels[pixel_offset + which_solution] = 255;
                                } );
                            }
                        }
                        else {
                            // plot pixel
                            if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height ) {
                                var pixel_offset = ( Math.floor(sp.y) * image.width + Math.floor(sp.x) ) * 4;
                                pixels[pixel_offset + which_solution] = 255;
                            }
                        }
                        old_p = p;
                        old_sp = sp;
                        have_old_p = true;
                        n_pts++;
                    }
                }
                return n_pts;
            };
            var n_pts = 0;
            var level = 15;
            for( var k = 0; k < 4; k++) {
                n_pts += explore_tree( transforms[k], k, level );
            }
            document.getElementById('num_points_text').textContent = "Number of points: " + n_pts;
        }
    }
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input[type='button'], select, label, p {
    font-size: 20px;
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
}
</style>

</head>

<body>

<div style="float:left;touch-action:none"><p><canvas id="canvas" width="700" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

<div style="float:left;padding-left: 20px">

<p><input type="button" value="Draw control points: ON" onclick="onDrawControlPointsButton(this)" /></p>
<p><input type="button" id="hq_mode_button" value="High quality mode: OFF" onclick="onHighQualityModeButton(this)" /></p>
<p><input type="button" value="Animate control points: OFF" onclick="onAnimateModeButton(this)" /></p>
<p><label for="recipes_dropdown">Choose a recipe:</label><br><select id="recipes_dropdown" onchange="onRecipeChanged(this)"></select></p>
<p id="num_points_text"></p>

</div>

<div style="clear:both">

<p>This is work in progress. Get in touch if you have questions.</p>

<p>The image shows the points generated by an <a href="https://en.wikipedia.org/wiki/Iterated_function_system">IFS</a> using four <a href="index.html">Möbius transformations</a>. Try dragging the control points around.</p>

<p>See the book Indra's Pearls for details of what this is about. See <a href="ifs.html">this page</a> for a more general Möbius-IFS system.</p>

<hr>

<p>Source code: <a href="https://github.com/timhutton/mobius-transforms">https://github.com/timhutton/mobius-transforms</a></p>

</div>

</html>
