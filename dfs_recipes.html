<!DOCTYPE html>
<!--
    mobius-transforms - Exploring Möbius transformations and implementing the book Indra's Pearls
    Copyright (C) 2022 Tim J. Hutton

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
<meta charset="UTF-8">
<script src="code/math.js"></script>
<script src="code/recipes.js"></script>
<script src="code/threejs/three.min.js"></script>
<script src="code/threejs/DragControls.js"></script>
<script src="code/threejs/OrbitControls.js"></script>
<script>

function init() {
    draw_control_points = true;

    // initialise the recipes
    recipes = get_recipes();
    var recipes_dropdown = document.getElementById('recipes_dropdown');
    for( var i = 0; i < recipes.length; i++ ) {
        var el = document.createElement("option");
        el.textContent = recipes[i].label;
        el.value = recipes[i].label;
        recipes_dropdown.appendChild(el);
    }
    iRecipe = 8;
    recipes_dropdown.selectedIndex = iRecipe;

    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }

    plot_solution = [ true, true ];
    document.getElementById("which_solution_dropdown").selectedIndex = 2;

    plot_ifs = false;
    plot_dfs = true;
    document.getElementById("which_method_dropdown").selectedIndex = 1;

    hq_mode = false;
    set_quality_parameters( hq_mode );

    init3js();

    compute_and_redraw();
}

function init3js() {
    canvas2 = document.getElementById('canvas2');

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 'rgb(0,0,0)' );

    // add rendering for line segments
    line_segments = [[],[]]
    const line_materials = [ new THREE.LineBasicMaterial({ color: 'rgb(255,0,0)' }), new THREE.LineBasicMaterial({ color: 'rgb(0,255,0)' }) ];
    line_geometry = [ new THREE.BufferGeometry(), new THREE.BufferGeometry() ];
    line_geometry[0].setAttribute( 'position', new THREE.Float32BufferAttribute( line_segments[0], 3 ) );
    line_geometry[1].setAttribute( 'position', new THREE.Float32BufferAttribute( line_segments[1], 3 ) );
    scene.add( new THREE.LineSegments( line_geometry[0], line_materials[0] ) );
    scene.add( new THREE.LineSegments( line_geometry[1], line_materials[1] ) );

    // add rendering for points
    vertices = [[],[]]
    const point_materials = [ new THREE.PointsMaterial({ color: 'rgb(255,0,0)' }), new THREE.PointsMaterial({ color: 'rgb(0,255,0)' }) ];
    point_geometry = [ new THREE.BufferGeometry(), new THREE.BufferGeometry() ];
    point_geometry[0].setAttribute( 'position', new THREE.Float32BufferAttribute( vertices[0], 3 ) );
    point_geometry[1].setAttribute( 'position', new THREE.Float32BufferAttribute( vertices[1], 3 ) );
    scene.add( new THREE.Points( point_geometry[0], point_materials[0] ) );
    scene.add( new THREE.Points( point_geometry[1], point_materials[1] ) );

    control_point_meshes = [];

    camera1 = new THREE.OrthographicCamera( -3, 3, 3, -3 );
    camera1.position.set(0, 0, 1);
    camera1.up.set(0, 1, 0);
    camera1.lookAt(0, 0, 0);
    scene.add( camera1 );

    renderer = new THREE.WebGLRenderer({ antialias: false, canvas: canvas2 });

    orbit_controls = new THREE.OrbitControls( camera1, renderer.domElement );
    orbit_controls.enableRotate = false;
    orbit_controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
    orbit_controls.touches.ONE = THREE.TOUCH.PAN;
    orbit_controls.addEventListener( 'change', onCameraChange, false );

    control_point_meshes = [];
    resetControlPointMeshes( scene );
    const drag_controls = new THREE.DragControls( control_point_meshes, camera1, renderer.domElement );
    drag_controls.addEventListener( 'dragstart', () => orbit_controls.enabled = false );
    drag_controls.addEventListener( 'dragend', () => orbit_controls.enabled = true );
    drag_controls.addEventListener( 'drag', onDragControlPoint, false );

    canvas2.addEventListener( 'mousemove', render, false );
    canvas2.addEventListener( 'touchmove', render, false );
    canvas2.addEventListener( 'mousedown',  render, false );
    canvas2.addEventListener( 'touchstart',  render, false );
    canvas2.addEventListener( 'mouseup',  render, false );
    canvas2.addEventListener( 'mouseout',  render, false );
    canvas2.addEventListener( 'touchend',  render, false );
    canvas2.addEventListener( 'touchcancel',  render, false );
    canvas2.addEventListener( 'wheel',  render, false );
}

function onDragControlPoint( e ) {
    const mesh = e.object;
    const iControlPoint = control_point_meshes.indexOf( mesh );
    if( iControlPoint == -1 ) { console.log('unknown dragged object'); return; }
    control_points[ iControlPoint ].x = mesh.position.x;
    control_points[ iControlPoint ].y = mesh.position.y;
    compute_and_redraw();
}

function onCameraChange() {
    // set size of the control_points depending on the zoom
    const scale = 1.0 / camera1.zoom;
    for(var i = 0; i < control_point_meshes.length; i++) {
        control_point_meshes[i].scale.x = scale;
        control_point_meshes[i].scale.y = scale;
        control_point_meshes[i].scale.z = scale;
    }
}

function resetCamera() {
    orbit_controls.reset();
}

function resetControlPointMeshes( scene ) {
    for( var i = 0; i < control_point_meshes.length; i++) {
        scene.remove( control_point_meshes[i] );
    }
    control_point_meshes.length = 0;
    const control_point_size = 0.2;
    const control_point_geometry = new THREE.BoxGeometry( control_point_size, control_point_size, control_point_size );
    const control_point_material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
    for( var i = 0; i < control_points.length; i++) {
        var mesh = new THREE.Mesh( control_point_geometry, control_point_material );
        mesh.position.set( control_points[i].x, control_points[i].y, 0.0 );
        scene.add( mesh );
        control_point_meshes.push( mesh );
    }
}

function render() {
    renderer.render( scene, camera1 );
}

function updateScene() {
    line_geometry[0].setAttribute( 'position', new THREE.Float32BufferAttribute( line_segments[0], 3 ) );
    line_geometry[1].setAttribute( 'position', new THREE.Float32BufferAttribute( line_segments[1], 3 ) );
    point_geometry[0].setAttribute( 'position', new THREE.Float32BufferAttribute( vertices[0], 3 ) );
    point_geometry[1].setAttribute( 'position', new THREE.Float32BufferAttribute( vertices[1], 3 ) );
    render();
}

function onDrawControlPointsButton(element) {
    draw_control_points = !draw_control_points;
    element.value = draw_control_points ? "Draw control points: ON" : "Draw control points: OFF";
    draw();
}

function onRecipeChanged(element) {
    iRecipe = recipes_dropdown.selectedIndex;
    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }
    hq_mode = false;
    updateHighQualityModeButton();
    set_quality_parameters( hq_mode );
    resetControlPointMeshes( scene );
    resetCamera();
    compute_and_redraw();
}

function set_quality_parameters(hq_mode) {
    if( hq_mode ) {
        num_ifs_iterations = 10000000;
        max_depth = 100;
        closeness_epsilon = 0.003; // if sequential points are closer than this we can stop searching
    }
    else {
        num_ifs_iterations = 100000;
        max_depth = 25;
        closeness_epsilon = 0.01; // if sequential points are closer than this we can stop searching
    }
    document.getElementById('epsilon_input').value = closeness_epsilon;
    document.getElementById('maximum_depth_input').value = max_depth;
    closeness_epsilon2 = closeness_epsilon * closeness_epsilon;
}

function onMaxDepthChanged(element) {
    max_depth = element.value;
    compute_and_redraw();
}

function onEpsilonChanged(element) {
    closeness_epsilon = element.value;
    const min_closeness_epsilon = 0.00001;
    if( closeness_epsilon < min_closeness_epsilon ) {
        closeness_epsilon = min_closeness_epsilon;
        element.value = closeness_epsilon;
    }
    closeness_epsilon2 = closeness_epsilon * closeness_epsilon;
    compute_and_redraw();
}

function onHighQualityModeButton(element) {
    hq_mode = !hq_mode;
    updateHighQualityModeButton();
    set_quality_parameters( hq_mode );
    compute_and_redraw();
}

function updateHighQualityModeButton() {
    document.getElementById('hq_mode_button').value = hq_mode ? "High quality mode: ON" : "High quality mode: OFF";
}

function onWhichSolutionChanged(element) {
    plot_solution[0] = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_solution[1] = element.selectedIndex == 1 || element.selectedIndex == 2;
    compute_and_redraw();
}

function onWhichMethodChanged(element) {
    plot_ifs = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_dfs = element.selectedIndex == 1 || element.selectedIndex == 2;
    compute_and_redraw();
}

function download(filename, type, text) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:'+type+';charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

function getBoundsWithDuplication( pts, duplication_func ) {
    var bounds = { minX: Number.MAX_VALUE, minY: Number.MAX_VALUE, maxX: -Number.MAX_VALUE, maxY: -Number.MAX_VALUE };
    for( var i = 0; i < pts.length; i++) {
        if( isNaN( pts[i].x ) || isNaN( pts[i].y ) ) { continue; }
        var pts_dup = duplication_func( pts[i] );
        for( var j = 0; j < pts_dup.length; j++ ) {
            if( pts_dup[j].x < bounds.minX ) { bounds.minX = pts_dup[j].x; }
            if( pts_dup[j].y < bounds.minY ) { bounds.minY = pts_dup[j].y; }
            if( pts_dup[j].x > bounds.maxX ) { bounds.maxX = pts_dup[j].x; }
            if( pts_dup[j].y > bounds.maxY ) { bounds.maxY = pts_dup[j].y; }
        }
    }
    bounds.width = bounds.maxX - bounds.minX;
    bounds.height = bounds.maxY - bounds.minY;
    return bounds;
}

function getOutputPtsBoundsWithDuplication( scale, duplication_func ) {
    var all_pts = [];
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        for(var i = 0; i < output_pts[which_solution].length; i++) {
            for(var j = 0; j < output_pts[which_solution][i].length; j++) {
                all_pts.push( mul( output_pts[which_solution][i][j], scale) );
            }
        }
    }
    var bounds = getBoundsWithDuplication( all_pts, duplication_func );
    return bounds;
}

function onSaveAsSVGButton(element) {
    var scale = 300;
    var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
    var bounds = getOutputPtsBoundsWithDuplication( scale, duplication_func );
    var svg = "<!-- SVG produced by https://github.com/timhutton/mobius-transforms -->\n";
    svg += "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' width='"+bounds.width.toFixed(1)+"px' height='"+bounds.height.toFixed(1)+"px' viewBox='"
        + bounds.minX.toFixed(1) + " " + bounds.minY.toFixed(1) + " " + bounds.width.toFixed(1) + " " + bounds.height.toFixed(1) + "'>\n";
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        for(var i = 0; i < output_pts[which_solution].length; i++) {
            var pts_dup = [];
            for( var k = 0; k < output_pts[which_solution][i].length; k++ ) {
                pts_dup.push( duplication_func( output_pts[which_solution][i][k] ) );
            }
            for( var k = 0; k < pts_dup[0].length; k++ ) {
                svg += "  <polyline points='";
                for( var iPt = 0; iPt < pts_dup.length; iPt++) {
                    var sp = mul( pts_dup[iPt][k], scale );
                    svg += sp.x.toFixed(3) + ", " + sp.y.toFixed(3) + " "
                }
                svg += "'\n    fill='none' stroke='black' stroke-width='0.3'/>\n";
            }
        }
    }
    svg += "</svg>\n";
    download("dfs.svg", "image/svg+xml", svg);
}

function onSaveAsPNGButton(element) {
    var max_image_dimension = 3000;
    var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
    var bounds = getOutputPtsBoundsWithDuplication( 1.0, duplication_func );
    var scale = max_image_dimension / Math.max( bounds.width, bounds.height );
    var width = bounds.width * scale;
    var height = bounds.height * scale;
    var border = 5;
    // create a large canvas
    var new_canvas = document.createElement('canvas');
    new_canvas.width = width + border * 2;
    new_canvas.height = height + border * 2;
    var context = new_canvas.getContext('2d');
    context.fillStyle = 'rgb(255,255,255)';
    context.fillRect(0, 0, new_canvas.width, new_canvas.height);
    // draw the whole loop
    context.strokeStyle = 'rgba(0,0,0,1.0)';
    context.fillStyle = 'rgba(247, 246, 216, 1.0)';
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        for( var j = 0; j < output_pts[which_solution].length; j++) {
            if(output_pts[which_solution][j].length == 0) { continue; }
            var pts_dup = [];
            for( var k = 0; k < output_pts[which_solution][j].length; k++ ) {
                pts_dup.push( duplication_func( output_pts[which_solution][j][k] ) );
            }
            for( var k = 0; k < pts_dup[0].length; k++ ) {
                context.beginPath();
                var sp0 = add( mul( sub( pts_dup[0][k], p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border ) );
                context.moveTo( sp0.x, new_canvas.height - sp0.y );
                for(var i = 1; i < pts_dup.length; i++) {
                    var sp = add( mul( sub( pts_dup[i][k], p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border) );
                    context.lineTo( sp.x, new_canvas.height - sp.y );
                }
                context.stroke();
            }
        }
    }
    // save the png
    var downloadLink = document.createElement('a');
    downloadLink.download = 'dfs.png';
    downloadLink.href = new_canvas.toDataURL('image/png');
    downloadLink.click();
}

function compute_and_redraw() {
    document.getElementById('rendering_text').textContent = "Rendering...";
    setTimeout(function() {

        const time_start = performance.now();

        var [dfs_succeeded, n_pts_plotted, description] = compute();
        updateScene();
        render();

        const time_end = performance.now();
        const ms_elapsed = time_end - time_start;
        if( ms_elapsed > 1000.0 ) {
            document.getElementById('rendering_text').textContent = "Last render took: "+(ms_elapsed/1000.0).toFixed(2)+"s";
        }
        else {
            document.getElementById('rendering_text').textContent = "Last render took: "+ms_elapsed.toFixed(2)+"ms";
        }
        if( n_pts_plotted > 0 ) {
            document.getElementById('num_points_text').textContent = "Number of points: " + n_pts_plotted;
        }
        else {
            document.getElementById('num_points_text').textContent = "Aborted rendering";
        }
        document.getElementById('download_svg_button').disabled = !dfs_succeeded;
        document.getElementById('download_png_button').disabled = !dfs_succeeded;
        document.getElementById('description_text').innerHTML = "Description: " + description;
    }, 1 );
}

function format_complex( a ) {
    return `${ a.x.toFixed(3) } ${ a.y >= 0.0 ? "+" : "-" } ${ Math.abs(a.y).toFixed(3) }i`;
}

function make_generators(which_solution) {
    // construct the four Mobius transformations we will be using
    var [transforms, description] = recipes[ iRecipe ].make_generators(which_solution, control_points);
    transforms[2] = get_mobius_inverse( transforms[0] );
    transforms[3] = get_mobius_inverse( transforms[1] );
    return [transforms, description];
}

function duplicate_point( a, recipe ) {
    // return a list of the duplicated points according to the duplication method specified in the recipe
    var pts = [];
    if( !('duplicate' in recipe) ) {
        pts.push( a );
    }
    else if( recipe.duplicate == 'rot180' ) {
        pts.push( a );
        pts.push( mul(a, -1.0) );
    }
    else if( recipe.duplicate == 'rot180_and_rep_x_2' ) { // e.g. riley
        for( var x_offset = -4; x_offset <= 4; x_offset += 2 ) {
            pts.push( add( a, p2( x_offset, 0.0 ) ) );
            pts.push( add( mul(a, -1.0), p2( x_offset, 0.0 ) ) );
        }
    }
    else if( recipe.duplicate == 'maskit' ) {
        var mu = control_points[0];
        for( var x_offset = -4; x_offset <= 4; x_offset += 2 ) {
            pts.push( add( a, p2( x_offset, 0.0 ) ) );
            pts.push( add( mul( sub( a, mu ), -1.0), p2( x_offset, 0.0 ) ) );
        }
    }
    else {
        //console.log('Unknown duplication command:', recipe.duplicate);
        pts.push( a );
    }
    return pts;
}

function mod4( x ) {
    while( x < 0 ) { x += 4; }
    return x % 4;
}

function last(arr) { return arr[arr.length - 1]; }

function find_nearby_short_word_fixed_points( sp, transforms, which_solution, debug_pts) {
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:B, name:'B'}, {t:A, name:'A'}, {t:b, name:'b'} ];
    var fixed_points_max_depth = 6;
    var shortest_len = 10000;
    var p;
    var found_one = false;
    function explore_tree( x, old_word, prev, level ) {
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var new_word = old_word + gens[ iTag ].name;
            var fp = { p: get_mobius_fixed_points( y )[0], label: new_word };
            var sfp = toScreen( fp.p );
            if( dist2( sp, sfp ) < 400.0 && fp.label.length < shortest_len) {
                shortest_len = fp.label.length;
                p = fp;
                found_one = true;
            }
            if( level < fixed_points_max_depth ) {
                explore_tree( y, new_word, iTag, level + 1 );
            }
        }
    };
    for( var k = 0; k < 4; k++) {
        explore_tree( gens[k].t, gens[k].name, k, 0 );
    }
    if( found_one )
        debug_pts[which_solution] = [ p ];
}

function find_fixed_points(transforms, which_solution, debug_pts) {
    // for debugging which special words are appropriate for a particular pattern
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:B, name:'B'}, {t:A, name:'A'}, {t:b, name:'b'} ];
    var fixed_points_max_depth = 2;
    function explore_tree( x, old_word, prev, level ) {
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var new_word = old_word + gens[ iTag ].name;
            var fp = { p: get_mobius_fixed_points( y )[0], label: new_word };
            debug_pts[which_solution].push( fp );
            if( level < fixed_points_max_depth ) {
                explore_tree( y, new_word, iTag, level + 1 );
            }
        }
    };
    for( var k = 0; k < 4; k++) {
        var fp = { p: get_mobius_fixed_points( gens[k].t )[0], label: gens[k].name };
        debug_pts[which_solution].push( fp );
        explore_tree( gens[k].t, gens[k].name, k, 0 );
    }
}

function get_repetends( transforms ) {
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:b, name:'b'}, {t:A, name:'A'}, {t:B, name:'B'} ];
    var bABa = get_mobius_composed(b, A, B, a);
    var BAba = get_mobius_composed(B, A, b, a);
    var ABab = get_mobius_composed(A, B, a, b);
    var aBAb = get_mobius_composed(a, B, A, b);
    var BabA = get_mobius_composed(B, a, b, A);
    var baBA = get_mobius_composed(b, a, B, A);
    var abAB = get_mobius_composed(a, b, A, B);
    var AbaB = get_mobius_composed(A, b, a, B);
    var aaB = get_mobius_composed(a, a, B);
    var aBa = get_mobius_composed(a, B, a);
    var Baa = get_mobius_composed(B, a, a);
    var AAb = get_mobius_composed(A, A, b);
    var AbA = get_mobius_composed(A, b, A);
    var bAA = get_mobius_composed(b, A, A);
    var repetends = [ [ // each in alphabetical order per abAB with the next letter from [1,0,-1] mod 4, ie:
                        //  after a we get: b,a,B
                        //  after B we get: a,B,A
                        //  after A we get: B,A,b
                        //  after b we get: A,b,a
            { p: get_mobius_fixed_points( bABa )[0], label: '|bABa' },
            { p: get_mobius_fixed_points( a )[0],    label: '|a' },
            //{ p: get_mobius_fixed_points( aBa )[0],  label: '|aBa' },
            //{ p: get_mobius_fixed_points( Baa )[0],  label: '|Baa' },
            { p: get_mobius_fixed_points( BAba )[0], label: '|BAba' },
        ], [
            { p: get_mobius_fixed_points( ABab )[0], label: '|ABab' },
            { p: get_mobius_fixed_points( b )[0],    label: '|b' },
            //{ p: get_mobius_fixed_points( AAb )[0],  label: '|AAb' },
            { p: get_mobius_fixed_points( aBAb )[0], label: '|aBAb' },
        ], [
            { p: get_mobius_fixed_points( BabA )[0], label: '|BabA' },
            { p: get_mobius_fixed_points( A )[0],    label: '|A' },
            //{ p: get_mobius_fixed_points( AbA )[0],  label: '|AbA' },
            //{ p: get_mobius_fixed_points( bAA )[0],  label: '|bAA' },
            { p: get_mobius_fixed_points( baBA )[0], label: '|baBA' },
        ], [
            { p: get_mobius_fixed_points( abAB )[0], label: '|abAB' },
            { p: get_mobius_fixed_points( B )[0],    label: '|B' },
            //{ p: get_mobius_fixed_points( aaB )[0],  label: '|aaB' },
            { p: get_mobius_fixed_points( AbaB )[0], label: '|AbaB' },
        ]
    ];
    return [gens, repetends];
}

function dfs_recursive_tree(gens, repetends, which_solution, output_pts) {
    const max_d2 = 1.0;
    var duplication_func = p => duplicate_point( p, recipes[ iRecipe ] );
    function explore_tree( x, prev, level ) {
        var n_pts = 0;
        for( var k = prev + 1; k >= prev - 1; k--) {
            const iTag = mod4( k );
            const y = get_mobius_composed( x, gens[ iTag ].t );
            var z = [];
            var close_enough = true;
            for(var i = 0; i < repetends[iTag].length; i++) {
                z.push( mobius_on_point( y, repetends[iTag][i].p ) );
                if( i > 0 ) {
                    const d2 = dist2( z[i], z[i-1] );
                    if( d2 > closeness_epsilon2 ) { close_enough = false; }
                    if( d2 > max_d2 && level >= max_depth ) {
                        // if there are still very long lines at max_depth then we need to abort
                        return -1;
                    }
                }
            }
            if( close_enough || level >= max_depth ) {
                if( close_enough ) {
                    // store the line segments
                    output_pts[which_solution].push( z );
                    var pts_dup = [];
                    for( var j = 0; j < z.length; j++ ) {
                        pts_dup.push( duplication_func( z[j] ) );
                    }
                    for( var j = 0; j < pts_dup[0].length; j++ ) {
                        for( var i = 0; i < pts_dup.length - 1; i++ ) {
                            line_segments[which_solution].push( pts_dup[i][j].x );
                            line_segments[which_solution].push( pts_dup[i][j].y );
                            line_segments[which_solution].push( 0 );
                            line_segments[which_solution].push( pts_dup[i+1][j].x );
                            line_segments[which_solution].push( pts_dup[i+1][j].y );
                            line_segments[which_solution].push( 0 );
                        }
                    }
                }
                else {
                    // store the points
                    for( var j = 0; j < z.length; j++ ) {
                        const pt_dup = duplication_func( z[j] );
                        for(var i = 0; i < pt_dup.length; i++) {
                            vertices[which_solution].push( pt_dup[i].x );
                            vertices[which_solution].push( pt_dup[i].y );
                            vertices[which_solution].push( 0.0 );
                        }
                    }
                }
                n_pts += z.length;
            }
            else {
                const ret = explore_tree( y, iTag, level + 1 );
                if( ret == -1) { return -1; } // the abort signal bubbles up the stack
                n_pts += ret;
            }
        }
        return n_pts;
    };
    var n_pts_plotted = 0;
    var start_letters = [0, 3, 2, 1]; // default order: aBAb
    if( 'start_letters' in recipes[iRecipe] ) { start_letters = recipes[iRecipe].start_letters; }
    for( var iStartLetter = 0; iStartLetter < start_letters.length; iStartLetter++) {
        const iTag = start_letters[iStartLetter];
        const ret = explore_tree( gens[iTag].t, iTag, 1 );
        if( ret == -1 ) {
            return 0; // drawing was aborted
        }
        n_pts_plotted += ret;
    }
    return n_pts_plotted;
}

function draw_ifs(transforms, which_solution) {
    var discard = 20;
    var p = p2(0.0,0.0);
    for( var i = 0; i < num_ifs_iterations + discard; i++) {
        p = mobius_on_point( transforms[Math.floor(Math.random() * transforms.length)], p );
        if( i > discard ) {
            cloud_pts[which_solution].push( p );
            vertices[which_solution].push( p.x );
            vertices[which_solution].push( p.y );
            vertices[which_solution].push( 0.0 );
        }
    }
    return num_ifs_iterations;
}

function compute() {

    var n_pts_plotted = 0;
    output_pts = [[],[]];
    debug_pts = [[],[]];
    cloud_pts = [[],[]];
    vertices = [[],[]];
    line_segments = [[],[]];
    transforms = [];
    var description = "";
    var dfs_succeeded = true;

    if( plot_dfs ) {
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators( which_solution );
            var [gens, repetends] = get_repetends( transforms );
            n_pts_plotted += dfs_recursive_tree( gens, repetends, which_solution, output_pts );
        }
    }

    if(n_pts_plotted == 0) {
        // DFS rendering failed, clear the drawing and draw IFS instead
        dfs_succeeded = false;
        output_pts = [[],[]];
        vertices = [[],[]];
        line_segments = [[],[]];
    }

    if(!dfs_succeeded || plot_ifs) {
        // run IFS
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators( which_solution );
            n_pts_plotted += draw_ifs( transforms, which_solution );
        }
    }

    return [dfs_succeeded, n_pts_plotted, description];
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input, select, label, p {
    font-size: 20px;
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
    padding-right: 5px;
}
</style>

</head>

<body>

<div style="float:left;touch-action:none"><p><canvas id="canvas2" width="600" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

<div style="float:left;padding-left: 20px">

<p><label for="recipes_dropdown">Choose a recipe:</label><br><select id="recipes_dropdown" onchange="onRecipeChanged(this)"></select></p>
<p><input type="button" id="hq_mode_button" value="High quality mode: OFF" onclick="onHighQualityModeButton(this)" /></p>
<p><label for="maximum_depth_input">Max search depth:</label>
<input type="number" id="maximum_depth_input" min="1" max="500" value="25" size="4" onchange="onMaxDepthChanged(this)"></p>
<p><label for="epsilon_input">Epsilon:</label><input type="number" id="epsilon_input" min="0" max="10" value="0.01" step="0.001" size="10" onchange="onEpsilonChanged(this)"></p>
<p><label for="which_method_dropdown">Drawing method:</label><select id="which_method_dropdown" onchange="onWhichMethodChanged(this)">
  <option>IFS</option>
  <option>DFS</option>
  <option>both</option>
</select></p>
<p><input type="button" value="Draw control points: ON" onclick="onDrawControlPointsButton(this)" /></p>
<p><label for="which_solution_dropdown">Which solution to plot:</label><select id="which_solution_dropdown" onchange="onWhichSolutionChanged(this)">
  <option>a</option>
  <option>b</option>
  <option>both</option>
</select></p>
<p id="num_points_text"></p>
<p id="rendering_text"></p>
<p>
  <input type="button" id="download_png_button" value="Save as PNG" onclick="onSaveAsPNGButton(this)" />
  <input type="button" id="download_svg_button" value="Save as SVG" onclick="onSaveAsSVGButton(this)" />
</p>

</div>

<div style="clear:both">

<p id="description_text"></p>

<p>This is work in progress. Get in touch if you have questions.</p>

<p>The image shows the points generated by an <a href="https://en.wikipedia.org/wiki/Iterated_function_system">IFS</a> using four <a href="index.html">Möbius transformations</a>. Try dragging the control points around.</p>

<p>See the book Indra's Pearls for details of what this is about. See <a href="ifs.html">this page</a> for a more general Möbius-IFS system.</p>

<hr>

<p>Source code: <a href="https://github.com/timhutton/mobius-transforms">https://github.com/timhutton/mobius-transforms</a></p>

</div>

</html>
