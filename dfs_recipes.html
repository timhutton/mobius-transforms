<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="code/math.js"></script>
<script src="code/recipes.js"></script>
<script>

function toScreen( p ) {
    return add( origin_screen, complex_conjugate( mul( sub( p, offset ), scale ) ) );
}

function fromScreen( p ) {
    return add( mul( complex_conjugate( sub( p, origin_screen ) ), 1.0 / scale ), offset);
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    onMove( pos );
}

function onTouchMove( evt ) {
    if( point_is_being_dragged )
        evt.preventDefault();
    onMove( fixTouch( evt.changedTouches[0] ) );
}

function onMove( pos ) {
    if( point_is_being_dragged ) {
        control_points[ i_point ] = fromScreen( add( pos, drag_offset ) );
        compute_and_redraw();
    }
    else if( is_panning ) {
        var move = sub( fromScreen( drag_offset ), fromScreen( pos ) );
        offset = add( offset, move );
        draw();
        drag_offset = pos;
    }
    else {
        if( draw_fixed_points ) {
            debug_pts = [[],[]];
            for( var which_solution = 0; which_solution < 2; which_solution++) {
                find_nearby_short_word_fixed_points( pos, transforms, which_solution, debug_pts );
            }
            if( debug_pts[0].length > 0 || debug_pts[1].length > 0 ) {
                //console.log(debug_pts);
                draw();
            }
        }
        // find the closest point, if within a minimum radius
        var iClosest = -1;
        var closest_dist2 = touch_radius * touch_radius;
        var num_control_points = control_points.length;
        for( var i = 0; i < num_control_points; i++ ) {
            var d2 = dist2( pos, toScreen( control_points[ i ] ) );
            if( d2 < closest_dist2 ) {
                closest_dist2 = d2;
                iClosest = i;
            }
        }
        if( iClosest >= 0 ) {
            point_is_highlighted = true;
            i_point = iClosest;
            draw();
        }
        else if( point_is_highlighted ) {
            point_is_highlighted = false;
            draw();
        }
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    onDown( pos );
}

function onTouchStart( evt ) {
    onDown( fixTouch( evt.changedTouches[0] ) );
}

function onDown( pos ) {
    // find the closest point, if within a minimum radius
    var iClosest = -1;
    var closest_dist2 = touch_radius * touch_radius;
    var num_control_points = control_points.length;
    for( var i = 0; i < num_control_points; i++ ) {
        var d2 = dist2( pos, toScreen( control_points[ i ] ) );
        if( d2 < closest_dist2 ) {
            closest_dist2 = d2;
            iClosest = i;
        }
    }
    if( iClosest >= 0 ) {
        point_is_being_dragged = true;
        point_is_highlighted = false;
        i_point = iClosest;
        drag_offset = sub( toScreen( control_points[ i_point ] ), pos );
        draw();
    }
    else if( point_is_being_dragged ) {
        point_is_being_dragged = false;
        draw();
    }
    else if( point_is_highlighted ) {
        point_is_highlighted = false;
        draw();
    }
    else {
        is_panning = true;
        drag_offset = pos;
    }
}

function onMouseUp( evt ) {
    if( point_is_highlighted || point_is_being_dragged ) {
        point_is_highlighted = point_is_being_dragged = false;
        draw();
    }
    is_mouse_down = false;
    is_panning = false;
}

// thanks to: http://stackoverflow.com/a/12714084/126823
function fixTouch (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
        // iOS4 clientX/clientY have the value that should have been
        // in pageX/pageY. While pageX/page/ have the value 0
        x = x - winPageX;
        y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX) ) {
        // Some Android browsers have totally bogus values for clientX/Y
        // when scrolling/zooming a page. Detectable since clientX/clientY
        // should never be smaller than pageX/pageY minus page scroll
        x = touch.pageX - winPageX;
        y = touch.pageY - winPageY;
    }
    var rect = canvas.getBoundingClientRect();
    return p2( x - rect.left, y - rect.top );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas_rect = { x:0, y:0, width:canvas.width, height:canvas.height };

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onTouchMove, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchstart',  onTouchStart, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    canvas.addEventListener( 'touchend',  onMouseUp, false );
    canvas.addEventListener( 'touchcancel',  onMouseUp, false );

    origin_screen = p2( canvas.width/2, canvas.height/2 );
    reset_viewport();

    point_is_highlighted = false;
    point_is_being_dragged = false;
    is_panning = false;
    i_point = -1;
    grab_offset = p2( 0, 0 );

    touch_radius = 50;

    draw_control_points = true;
    draw_fixed_points = false;

    // initialise the recipes
    recipes = get_recipes();
    var recipes_dropdown = document.getElementById('recipes_dropdown');
    for( var i = 0; i < recipes.length; i++ ) {
        var el = document.createElement("option");
        el.textContent = recipes[i].label;
        el.value = recipes[i].label;
        recipes_dropdown.appendChild(el);
    }
    iRecipe = 8;
    recipes_dropdown.selectedIndex = iRecipe;

    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    image = ctx.getImageData(0, 0, canvas.width, canvas.height);
    pixels = image.data;

    plot_solution = [ true, true ];
    document.getElementById("which_solution_dropdown").selectedIndex = 2;

    plot_ifs = false;
    plot_dfs = true;
    document.getElementById("which_method_dropdown").selectedIndex = 1;

    closed_loop = false;

    hq_mode = false;
    set_quality_parameters( hq_mode );

    compute_and_redraw();
}

function reset_viewport() {
    scale = Math.min( canvas.width, canvas.height ) / 4.5;
    offset = p2( 0.0, 0.0 );
}

function drawPoint( p, r, t, t_offset ) {
    ctx.beginPath();
    ctx.arc( p.x, p.y, r, 0, 2.0 * Math.PI );
    ctx.fillText( t, p.x + t_offset.x - 5, p.y - t_offset.y );
    ctx.fill();
}

function draw() {

    clear_drawing();

    // draw the loop into the image buffer
    for( var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        if( true ) {
            if( closed_loop ) {
                if( output_pts[which_solution].length == 0 ) { continue; }
                // draw the loop
                var a = output_pts[which_solution][0].p, b;
                for(var i = 1; i < output_pts[which_solution].length; i++) {
                    b = output_pts[which_solution][i].p;
                    draw_image_line_with_duplication( a, b, which_solution, recipes[iRecipe] );
                    a = b;
                }
                b = output_pts[which_solution][0].p;
                draw_image_line_with_duplication( a, b, which_solution, recipes[iRecipe] );
            } else {
                // draw the separate line segments
                for(var i = 0; i < output_pts[which_solution].length; i++) {
                    if( output_pts[which_solution][i].length == 0 ) { continue; }
                    var a = output_pts[which_solution][i][0].p, b;
                    for(var j = 0; j < output_pts[which_solution][i].length; j++) {
                        b = output_pts[which_solution][i][j].p;
                        draw_image_line_with_duplication( a, b, which_solution, recipes[iRecipe] );
                        a = b;
                    }
                }
            }
        } else {
            // just draw as a cloud of points, for discrete patterns like Fig. 8.10 or maskit2 and 3
            // where the order we produce is wrong
            for( var i = 0; i < output_pts[which_solution].length; i++) {
                var sp = toScreen( output_pts[which_solution][i].p );
                if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height ) {
                    var pixel_offset = ( Math.floor(sp.y) * image.width + Math.floor(sp.x) ) * 4;
                    pixels[pixel_offset + which_solution] = 255;
                }
            }
        }
    }

    // draw the cloud points into the image buffer
    for( var which_solution = 0; which_solution < cloud_pts.length; which_solution++) {
        for( var i = 0; i < cloud_pts[which_solution].length; i++) {
            var sp = toScreen( cloud_pts[which_solution][i] );
            if( sp.x >= 0 && sp.y >=0 && sp.x < image.width && sp.y < image.height ) {
                var pixel_offset = ( Math.floor(sp.y) * image.width + Math.floor(sp.x) ) * 4;
                pixels[pixel_offset + which_solution] = 255;
            }
        }
    }

    // blit the image to the screen
    ctx.putImageData(image, 0, 0);

    // draw the axes
    if( draw_control_points ) {
        var min = fromScreen( p2( 0.0, canvas.height ) );
        var max = fromScreen( p2( canvas.width, 0.0 ) );
        min = p2( Math.floor( min.x ), Math.floor( min.y ) );
        max = p2( Math.ceil( max.x ), Math.ceil( max.y ) );
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.beginPath();
        drawLine( p2( min.x, 0 ), p2( max.x, 0 ) );
        drawLine( p2( 0, min.y ), p2( 0, max.y ) );
        // unit marks
        for( var x = min.x; x <= max.x; x++ ) {
            drawLine( p2( x, -0.05 ), p2( x, 0.05 ) );
        }
        for( var y = min.y; y <= max.y; y++ ) {
            drawLine( p2( -0.05, y ), p2( 0.05, y ) );
        }
        ctx.stroke();
    }

    // draw the control points
    if( draw_control_points ) {
        ctx.font="22px Arial";
        var rest_color = "rgb(255,255,255)";
        var highlighted_color = "rgb(0,255,255)";
        var dragging_color = "rgb(0,255,0)";
        for( var i = 0; i < control_points.length; i++ ) {
            if( point_is_highlighted && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = highlighted_color;
            else if( point_is_being_dragged && i_point == i )
                ctx.fillStyle = ctx.strokeStyle = dragging_color;
            else
                ctx.fillStyle = ctx.strokeStyle = rest_color;
            var radius = 4;
            var offset = p2( 20.0 * Math.cos(i * Math.PI), 20.0 * Math.sin(i * Math.PI) );
            drawPoint( toScreen( control_points[ i ] ), radius, recipes[ iRecipe ].pt_labels[i], offset );
        }
    }

    if( draw_fixed_points ) {
        ctx.font="12px Arial";
        ctx.fillStyle = "rgb(255,255,255)";
        for( var which_solution = 0; which_solution < debug_pts.length; which_solution++) {
            for( var i = 0; i < debug_pts[which_solution].length; i++ ) {
                drawPoint( toScreen( debug_pts[which_solution][i].p ), 2, debug_pts[which_solution][i].label, p2(Math.random()*40-20, Math.random()*40-20) );
            }
        }
    }

    // draw the debug labels
    if( false ) {
        ctx.font="12px Arial";
        ctx.fillStyle = "rgb(255,255,255)";
        for( var which_solution = 0; which_solution < output_pts.length; which_solution++) {
            for( var i = 0; i < output_pts[which_solution].length; i++ ) {
                if( closed_loop ) {
                    drawPoint( toScreen( output_pts[which_solution][ i ].p ), 2, i+':'+output_pts[which_solution][i].label, p2( 0, i%2==1?10:-10 ) );
                } else {
                    for( var j = 0; j < output_pts[which_solution][i].length; j++ ) {
                        drawPoint( toScreen( output_pts[which_solution][i][j].p ), 2, i+':'+j+':'+output_pts[which_solution][i][j].label, p2( 0, i%2==1?10:-10 ) );
                    }
                }
            }
        }
    }
}

function drawLine( a, b ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    ctx.moveTo( sa.x, sa.y );
    ctx.lineTo( sb.x, sb.y );
}

function onDrawControlPointsButton(element) {
    draw_control_points = !draw_control_points;
    element.value = draw_control_points ? "Draw control points: ON" : "Draw control points: OFF";
    draw();
}

function onRecipeChanged(element) {
    iRecipe = recipes_dropdown.selectedIndex;
    control_points = [];
    for(var i = 0; i < recipes[ iRecipe ].control_points.length; i++) {
        control_points.push( p2( recipes[ iRecipe ].control_points[i].x, recipes[ iRecipe ].control_points[i].y ) );
    }
    hq_mode = false;
    updateHighQualityModeButton();
    set_quality_parameters( hq_mode );
    reset_viewport();
    compute_and_redraw();
}

function set_quality_parameters(hq_mode) {
    if( hq_mode ) {
        num_ifs_iterations = 10000000;
        max_depth = 100;
        closeness_epsilon = 0.003; // if sequential points are closer than this we can stop searching
    }
    else {
        num_ifs_iterations = 100000;
        max_depth = 25;
        closeness_epsilon = 0.01; // if sequential points are closer than this we can stop searching
    }
    closeness_epsilon2 = closeness_epsilon * closeness_epsilon;
}

function onHighQualityModeButton(element) {
    hq_mode = !hq_mode;
    updateHighQualityModeButton();
    set_quality_parameters( hq_mode );
    compute_and_redraw();
}

function updateHighQualityModeButton() {
    document.getElementById('hq_mode_button').value = hq_mode ? "High quality mode: ON" : "High quality mode: OFF";
}

function onZoomInButton(element) {
    scale *= 2.0;
    draw();
}

function onZoomOutButton(element) {
    scale /= 2.0;
    draw();
}

function onWhichSolutionChanged(element) {
    plot_solution[0] = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_solution[1] = element.selectedIndex == 1 || element.selectedIndex == 2;
    compute_and_redraw();
}

function onWhichMethodChanged(element) {
    plot_ifs = element.selectedIndex == 0 || element.selectedIndex == 2;
    plot_dfs = element.selectedIndex == 1 || element.selectedIndex == 2;
    compute_and_redraw();
}

function download(filename, type, text) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:'+type+';charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

function getBounds(pts) {
    var bounds = { minX: Number.MAX_VALUE, minY: Number.MAX_VALUE, maxX: -Number.MAX_VALUE, maxY: -Number.MAX_VALUE };
    for( var i = 0; i < pts.length; i++) {
        if( !isNaN( pts[i].x ) && pts[i].x < bounds.minX ) { bounds.minX = pts[i].x; }
        if( !isNaN( pts[i].y ) && pts[i].y < bounds.minY ) { bounds.minY = pts[i].y; }
        if( !isNaN( pts[i].x ) && pts[i].x > bounds.maxX ) { bounds.maxX = pts[i].x; }
        if( !isNaN( pts[i].y ) && pts[i].y > bounds.maxY ) { bounds.maxY = pts[i].y; }
    }
    bounds.width = bounds.maxX - bounds.minX;
    bounds.height = bounds.maxY - bounds.minY;
    return bounds;
}

function getOutputPtsBounds(scale = 1.0) {
    var all_pts = [];
    if( closed_loop ) {
        for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
            for(var i = 0; i < output_pts[which_solution].length; i++) {
                all_pts.push( mul(output_pts[which_solution][i].p, scale) );
            }
        }
    } else {
        for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
            for(var i = 0; i < output_pts[which_solution].length; i++) {
                for(var j = 0; j < output_pts[which_solution][i].length; j++) {
                    all_pts.push( mul( output_pts[which_solution][i][j].p, scale) );
                }
            }
        }
    }
    var bounds = getBounds(all_pts);
    return bounds;
}

function onSaveAsSVGButton(element) {
    var scale = 300;
    var bounds = getOutputPtsBounds(scale);
    var svg = "<!-- SVG produced by https://github.com/timhutton/mobius-transforms -->\n";
    svg += "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' width='"+bounds.width.toFixed(1)+"px' height='"+bounds.height.toFixed(1)+"px' viewBox='"
        + bounds.minX.toFixed(1) + " " + bounds.minY.toFixed(1) + " " + bounds.width.toFixed(1) + " " + bounds.height.toFixed(1) + "'>\n";
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        if( closed_loop ) {
            svg += "  <polygon points='";
            for( var iPt = 0; iPt < output_pts[which_solution].length; iPt++) {
                var sp = mul( output_pts[which_solution][iPt].p, scale );
                svg += sp.x.toFixed(3) + ", " + sp.y.toFixed(3) + " "
            }
            svg += "'\n    fill='rgb(247, 246, 216)' stroke='black' stroke-width='0.3'/>\n";
        } else {
            for(var i = 0; i < output_pts[which_solution].length; i++) {
                svg += "  <polyline points='";
                for( var iPt = 0; iPt < output_pts[which_solution][i].length; iPt++) {
                    var sp = mul( output_pts[which_solution][i][iPt].p, scale );
                    svg += sp.x.toFixed(3) + ", " + sp.y.toFixed(3) + " "
                }
                svg += "'\n    fill='none' stroke='black' stroke-width='0.3'/>\n";
            }
        }
    }
    svg += "</svg>\n";
    download("dfs.svg", "image/svg+xml", svg);
}

function onSaveAsPNGButton(element) {
    var max_image_dimension = 3000;
    var bounds = getOutputPtsBounds();
    var scale = max_image_dimension / Math.max( bounds.width, bounds.height );
    var width = bounds.width * scale;
    var height = bounds.height * scale;
    var border = 5;
    // create a large canvas
    var new_canvas = document.createElement('canvas');
    new_canvas.width = width + border * 2;
    new_canvas.height = height + border * 2;
    var context = new_canvas.getContext('2d');
    context.fillStyle = 'rgb(255,255,255)';
    context.fillRect(0, 0, new_canvas.width, new_canvas.height);
    // draw the whole loop
    context.strokeStyle = 'rgba(0,0,0,1.0)';
    context.fillStyle = 'rgba(247, 246, 216, 1.0)';
    for(var which_solution = 0; which_solution < output_pts.length; which_solution++) {
        if( closed_loop ) {
            if(output_pts[which_solution].length == 0) { continue; }
            context.beginPath();
            var sp0 = add( mul( sub( output_pts[which_solution][0].p, p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border ) );
            context.moveTo( sp0.x, new_canvas.height - sp0.y );
            for(var i = 1; i < output_pts[which_solution].length; i++) {
                var sp = add( mul( sub( output_pts[which_solution][i].p, p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border) );
                context.lineTo( sp.x, new_canvas.height - sp.y );
            }
            context.lineTo( sp0.x, new_canvas.height - sp0.y );
            context.stroke();
            context.fill();
        } else {
            for( var j = 0; j < output_pts[which_solution].length; j++) {
                if(output_pts[which_solution][j].length == 0) { continue; }
                context.beginPath();
                var sp0 = add( mul( sub( output_pts[which_solution][j][0].p, p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border ) );
                context.moveTo( sp0.x, new_canvas.height - sp0.y );
                for(var i = 1; i < output_pts[which_solution][j].length; i++) {
                    var sp = add( mul( sub( output_pts[which_solution][j][i].p, p2( bounds.minX, bounds.minY ) ), scale ), p2( border, border) );
                    context.lineTo( sp.x, new_canvas.height - sp.y );
                }
                context.stroke();
            }
        }
    }
    // save the png
    var downloadLink = document.createElement('a');
    downloadLink.download = 'dfs.png';
    downloadLink.href = new_canvas.toDataURL('image/png');
    downloadLink.click();
}

function compute_and_redraw() {
    document.getElementById('rendering_text').textContent = "Rendering...";
    setTimeout(function() {

        const time_start = performance.now();

        var [dfs_succeeded, n_pts_plotted, description] = compute();
        draw();

        const time_end = performance.now();
        const ms_elapsed = time_end - time_start;
        if( ms_elapsed > 1000.0 ) {
            document.getElementById('rendering_text').textContent = "Last render took: "+(ms_elapsed/1000.0).toFixed(2)+"s";
        }
        else {
            document.getElementById('rendering_text').textContent = "Last render took: "+ms_elapsed.toFixed(2)+"ms";
        }
        if( n_pts_plotted > 0 ) {
            document.getElementById('num_points_text').textContent = "Number of points: " + n_pts_plotted;
        }
        else {
            document.getElementById('num_points_text').textContent = "Aborted rendering";
        }
        document.getElementById('download_svg_button').disabled = !dfs_succeeded;
        document.getElementById('download_png_button').disabled = !dfs_succeeded;
        document.getElementById('description_text').innerHTML = "Description: " + description;
    }, 1 );
}

function clear_drawing() {
    for( var i = 0; i < image.width * image.height; i++) {
        image.data[ i*4 + 0 ] = 0;
        image.data[ i*4 + 1 ] = 0;
        image.data[ i*4 + 2 ] = 0;
        image.data[ i*4 + 3 ] = 255;
    }
}

function format_complex( a ) {
    return `${ a.x.toFixed(3) } ${ a.y >= 0.0 ? "+" : "-" } ${ Math.abs(a.y).toFixed(3) }i`;
}

function make_generators(which_solution) {
    // construct the four Mobius transformations we will be using
    var [transforms, description] = recipes[ iRecipe ].make_generators(which_solution, control_points);
    transforms[2] = get_mobius_inverse( transforms[0] );
    transforms[3] = get_mobius_inverse( transforms[1] );
    return [transforms, description];
}

function draw_image_line_with_duplication( a, b, rgb, recipe) {
    if( !('duplicate' in recipe) ) {
        draw_image_line( a, b, rgb );
    }
    else {
        if( recipe.duplicate == 'rot180' ) {
            draw_image_line( a, b, rgb );
            draw_image_line( mul(a, -1.0), mul(b, -1.0), rgb );
        }
        else if( recipe.duplicate == 'rot180_and_rep_x_2' ) {
            for( var x_offset = -6; x_offset <= 6; x_offset += 2 ) {
                draw_image_line( add( a, p2( x_offset, 0.0 ) ), add( b, p2( x_offset, 0.0 ) ), rgb );
                draw_image_line( add( mul(a, -1.0), p2( x_offset, 0.0 ) ), add( mul(b, -1.0), p2( x_offset, 0.0 ) ), rgb );
            }
        }
        else {
            console.log('Unknown duplication command:', recipe.duplicate);
            draw_image_line( a, b, rgb );
        }
    }
}

function draw_image_line( a, b, rgb ) {
    var sa = toScreen( a );
    var sb = toScreen( b );
    // crop to the image rectangle if one or both points are outside
    if( sa.x < 0 || sa.y < 0 || sa.x >= image.width || sa.y >= image.height ||
        sb.x < 0 || sb.y < 0 || sb.x >= image.width || sb.y >= image.height ) {
        var image_corners = [ p2( 0, 0 ), p2( image.width - 1, 0 ), p2( image.width - 1, image.height - 1 ), p2( 0, image.height - 1 ) ];
        var intersections = [];
        for( var i = 0; i < image_corners.length; i++ ) {
            var [intersected, intersection] = find_line_segments_intersection( sa, sb, image_corners[i], image_corners[ (i + 1) % image_corners.length ] );
            if(intersected) { intersections.push( intersection ); }
        }
        if( intersections.length == 0 ) {
            return; // line segment doesn't cross the image
        }
        if( intersections.length == 2 ) {
            sa = intersections[0];
            sb = intersections[1];
        }
        else if( intersections.length == 1 ) {
            if( sa.x < 0 || sa.y < 0 || sa.x >= image.width || sa.y >= image.height )
                sa = intersections[0];
            else
                sb = intersections[0];
        }
        else {
            console.log('Strange number of intersections:', intersections.length, sa, sb);
            return;
        }
    }
    line( sa, sb, (x, y) => {
        if( x < 0 || y < 0 || x >= image.width || y >= image.height ) {
            console.log('Error in draw_image_line: pixel not on image', sa, sb, x, y);
            return;
        }
        pixels[( y * image.width + x ) * 4 + rgb] = 255;
    } );
}

function line(a, b, func) {
    var [x0, y0] = [ Math.trunc(a.x), Math.trunc(a.y) ];
    var [x1, y1] = [ Math.trunc(b.x), Math.trunc(b.y) ];
    if( isNaN(x0) || isNaN(y0) || isNaN(x1) || isNaN(y1) ) { return; }
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    var sx = (x0 < x1) ? 1 : -1;
    var sy = (y0 < y1) ? 1 : -1;
    var err = dx - dy;
    while(true) {
        func(x0, y0);
        if ((x0 === x1) && (y0 === y1)) break;
        var e2 = 2*err;
        if (e2 > -dy) { err -= dy; x0  += sx; }
        if (e2 < dx) { err += dx; y0  += sy; }
    }
}

function mod4( x ) {
    while( x < 0 ) { x += 4; }
    return x % 4;
}

function last(arr) { return arr[arr.length - 1]; }

function find_nearby_short_word_fixed_points( sp, transforms, which_solution, debug_pts) {
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:B, name:'B'}, {t:A, name:'A'}, {t:b, name:'b'} ];
    var fixed_points_max_depth = 6;
    var shortest_len = 10000;
    var p;
    var found_one = false;
    function explore_tree( x, old_word, prev, level ) {
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var new_word = old_word + gens[ iTag ].name;
            var fp = { p: get_mobius_fixed_points( y )[0], label: new_word };
            var sfp = toScreen( fp.p );
            if( dist2( sp, sfp ) < 400.0 && fp.label.length < shortest_len) {
                shortest_len = fp.label.length;
                p = fp;
                found_one = true;
            }
            if( level < fixed_points_max_depth ) {
                explore_tree( y, new_word, iTag, level + 1 );
            }
        }
    };
    for( var k = 0; k < 4; k++) {
        explore_tree( gens[k].t, gens[k].name, k, 0 );
    }
    if( found_one )
        debug_pts[which_solution] = [ p ];
}

function find_fixed_points(transforms, which_solution, debug_pts) {
    // for debugging which special words are appropriate for a particular pattern
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:B, name:'B'}, {t:A, name:'A'}, {t:b, name:'b'} ];
    var fixed_points_max_depth = 2;
    function explore_tree( x, old_word, prev, level ) {
        for( var k = prev - 1; k <= prev + 1; k++) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var new_word = old_word + gens[ iTag ].name;
            var fp = { p: get_mobius_fixed_points( y )[0], label: new_word };
            debug_pts[which_solution].push( fp );
            if( level < fixed_points_max_depth ) {
                explore_tree( y, new_word, iTag, level + 1 );
            }
        }
    };
    for( var k = 0; k < 4; k++) {
        var fp = { p: get_mobius_fixed_points( gens[k].t )[0], label: gens[k].name };
        debug_pts[which_solution].push( fp );
        explore_tree( gens[k].t, gens[k].name, k, 0 );
    }
}

function get_repetends( transforms ) {
    var [ a, b, A, B ] = transforms;
    var gens = [ {t:a, name:'a'}, {t:b, name:'b'}, {t:A, name:'A'}, {t:B, name:'B'} ];
    var bABa = get_mobius_composed(b, A, B, a);
    var BAba = get_mobius_composed(B, A, b, a);
    var ABab = get_mobius_composed(A, B, a, b);
    var aBAb = get_mobius_composed(a, B, A, b);
    var BabA = get_mobius_composed(B, a, b, A);
    var baBA = get_mobius_composed(b, a, B, A);
    var abAB = get_mobius_composed(a, b, A, B);
    var AbaB = get_mobius_composed(A, b, a, B);
    var aaB = get_mobius_composed(a, a, B);
    var aBa = get_mobius_composed(a, B, a);
    var Baa = get_mobius_composed(B, a, a);
    var AAb = get_mobius_composed(A, A, b);
    var AbA = get_mobius_composed(A, b, A);
    var bAA = get_mobius_composed(b, A, A);
    var repetends = [ [ // each in alphabetical order per abAB with the next letter from [1,0,-1] mod 4, ie:
                        //  after a we get: b,a,B
                        //  after B we get: a,B,A
                        //  after A we get: B,A,b
                        //  after b we get: A,b,a
            { p: get_mobius_fixed_points( bABa )[0], label: '|bABa' },
            //{ p: get_mobius_fixed_points( a )[0],    label: '|a' },
            //{ p: get_mobius_fixed_points( aBa )[0],  label: '|aBa' },
            //{ p: get_mobius_fixed_points( Baa )[0],  label: '|Baa' },
            { p: get_mobius_fixed_points( BAba )[0], label: '|BAba' },
        ], [
            { p: get_mobius_fixed_points( ABab )[0], label: '|ABab' },
            //{ p: get_mobius_fixed_points( b )[0],    label: '|b' },
            //{ p: get_mobius_fixed_points( AAb )[0],  label: '|AAb' },
            { p: get_mobius_fixed_points( aBAb )[0], label: '|aBAb' },
        ], [
            { p: get_mobius_fixed_points( BabA )[0], label: '|BabA' },
            //{ p: get_mobius_fixed_points( A )[0],    label: '|A' },
            //{ p: get_mobius_fixed_points( AbA )[0],  label: '|AbA' },
            //{ p: get_mobius_fixed_points( bAA )[0],  label: '|bAA' },
            { p: get_mobius_fixed_points( baBA )[0], label: '|baBA' },
        ], [
            { p: get_mobius_fixed_points( abAB )[0], label: '|abAB' },
            //{ p: get_mobius_fixed_points( B )[0],    label: '|B' },
            //{ p: get_mobius_fixed_points( aaB )[0],  label: '|aaB' },
            { p: get_mobius_fixed_points( AbaB )[0], label: '|AbaB' },
        ]
    ];
    return [gens, repetends];
}

function dfs_recursive_tree(gens, repetends, which_solution, output_pts) {
    var max_d2 = 1.0;
    function explore_tree( x, old_word, prev, level ) {
        var n_pts = 0;
        for( var k = prev + 1; k >= prev - 1; k--) {
            var iTag = mod4( k );
            var y = get_mobius_composed( x, gens[ iTag ].t );
            var z = [];
            var close_enough = true;
            for(var i = 0; i < repetends[iTag].length; i++) {
                z.push( { p: mobius_on_point( y, repetends[iTag][i].p ), label: old_word + repetends[iTag][i].label } );
                if( i > 0 ) {
                    var d2 = dist2( z[i].p, z[i-1].p );
                    if( d2 > closeness_epsilon2 ) { close_enough = false; }
                    if( d2 > max_d2 && level >= max_depth ) {
                        // if there are still very long lines at max_depth then we need to abort
                        return -1; // debug: no abort
                    }
                }
            }
            if( close_enough || level >= max_depth ) {
                // draw the line segments, we've reached the bottom
                if( closed_loop ) {
                    for(var i = 0; i < z.length; i++) {
                        output_pts[which_solution].push( z[i] );
                    }
                } else {
                    output_pts[which_solution].push( z );
                }
                n_pts += z.length;
            }
            else {
                var new_word = old_word + gens[ iTag ].name;
                var ret = explore_tree( y, new_word, iTag, level + 1 );
                if( ret == -1) { return -1; } // the abort signal bubbles up the stack
                n_pts += ret;
            }
        }
        return n_pts;
    };
    var n_pts_plotted = 0;
    var start_letters = [0, 3, 2, 1]; // default order: aBAb
    if( 'start_letters' in recipes[iRecipe] ) { start_letters = recipes[iRecipe].start_letters; }
    for( var iStartLetter = 0; iStartLetter < start_letters.length; iStartLetter++) {
        var iTag = start_letters[iStartLetter];
        if( closed_loop ) {
            output_pts[which_solution].push( { p: repetends[iTag][0].p, label: repetends[iTag][0].label } );
        }
        var ret = explore_tree( gens[iTag].t, gens[iTag].name, iTag, 1 );
        if( ret == -1 ) {
            return 0; // drawing was aborted
        }
        n_pts_plotted += ret;
        if( closed_loop ) {
            output_pts[which_solution].push( { p: last(repetends[iTag]).p, label: last(repetends[iTag]).label } ); // (not needed if the necklace condition applies)
        }
    }
    return n_pts_plotted;
}

function draw_ifs(transforms, which_solution) {
    var discard = 20;
    var p = p2(0.0,0.0);
    for( var i = 0; i < num_ifs_iterations + discard; i++) {
        p = mobius_on_point( transforms[Math.floor(Math.random() * transforms.length)], p );
        if( i > discard )
            cloud_pts[which_solution].push( p );
    }
    return num_ifs_iterations;
}

function compute() {

    var n_pts_plotted = 0;
    output_pts = [[],[]];
    debug_pts = [[],[]];
    cloud_pts = [[],[]];
    transforms = [];
    var description = "";
    var dfs_succeeded = true;

    if( plot_dfs ) {
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators( which_solution );
            var [gens, repetends] = get_repetends( transforms );
            n_pts_plotted += dfs_recursive_tree( gens, repetends, which_solution, output_pts );

            if( draw_fixed_points ) {
                find_fixed_points(transforms, which_solution, debug_pts);
            }
        }
    }

    if(n_pts_plotted == 0) {
        // DFS rendering failed, clear the drawing and draw IFS instead
        dfs_succeeded = false;
        output_pts = [[],[]];
        clear_drawing();
    }

    if(!dfs_succeeded || plot_ifs) {
        // run IFS
        for( var which_solution = 0; which_solution < 2; which_solution++ ) {
            if(! plot_solution[which_solution] ) { continue; }

            [transforms, description] = make_generators( which_solution );
            n_pts_plotted += draw_ifs( transforms, which_solution );
        }
    }

    return [dfs_succeeded, n_pts_plotted, description];
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

<style>
input[type='button'], select, label, p {
    font-size: 20px;
    font-family: Helvetica Neue,Helvetica,Arial,sans-serif;
    padding-right: 5px;
}
</style>

</head>

<body>

<div style="float:left;touch-action:none"><p><canvas id="canvas" width="700" height="600">(Canvas drawing not supported by your browser.)</canvas></p></div>

<div style="float:left;padding-left: 20px">

<p><label for="recipes_dropdown">Choose a recipe:</label><br><select id="recipes_dropdown" onchange="onRecipeChanged(this)"></select></p>
<p>
  <input type="button" id="zoom_in_button" value="Zoom in" onclick="onZoomInButton(this)" />
  <input type="button" id="zoom_out_button" value="Zoom out" onclick="onZoomOutButton(this)" />
</p>
<p><input type="button" id="hq_mode_button" value="High quality mode: OFF" onclick="onHighQualityModeButton(this)" /></p>
<p><label for="which_method_dropdown">Drawing method:</label><select id="which_method_dropdown" onchange="onWhichMethodChanged(this)">
  <option>IFS</option>
  <option>DFS</option>
  <option>both</option>
</select></p>
<p><input type="button" value="Draw control points: ON" onclick="onDrawControlPointsButton(this)" /></p>
<p><label for="which_solution_dropdown">Which solution to plot:</label><select id="which_solution_dropdown" onchange="onWhichSolutionChanged(this)">
  <option>a</option>
  <option>b</option>
  <option>both</option>
</select></p>
<p id="num_points_text"></p>
<p id="rendering_text"></p>
<p>
  <input type="button" id="download_png_button" value="Save as PNG" onclick="onSaveAsPNGButton(this)" />
  <input type="button" id="download_svg_button" value="Save as SVG" onclick="onSaveAsSVGButton(this)" />
</p>

</div>

<div style="clear:both">

<p id="description_text"></p>

<p>This is work in progress. Get in touch if you have questions.</p>

<p>The image shows the points generated by an <a href="https://en.wikipedia.org/wiki/Iterated_function_system">IFS</a> using four <a href="index.html">Möbius transformations</a>. Try dragging the control points around.</p>

<p>See the book Indra's Pearls for details of what this is about. See <a href="ifs.html">this page</a> for a more general Möbius-IFS system.</p>

<hr>

<p>Source code: <a href="https://github.com/timhutton/mobius-transforms">https://github.com/timhutton/mobius-transforms</a></p>

</div>

</html>
